"""
ğŸ¯ ê°„ì†Œí™”ëœ í†µí•© ë¶„ì„ íŒŒì´í”„ë¼ì¸
í‚¤ì›Œë“œ + LLM í•˜ì´ë¸Œë¦¬ë“œ ë¶„ë¥˜ë¡œ ì •í™•ë„ í–¥ìƒ
"""

import asyncio
import logging
from typing import Dict, List, Any, Optional
from datetime import datetime, date
import json

from src.text.advanced_analysis import SimplifiedClassifier, ClassificationResult
from src.db.advanced_manager import SimplifiedDBManager
from src.utils.structured_logger import StructuredLogger

logger = logging.getLogger(__name__)

class IntegratedAnalyzer:
    """í†µí•© ë¶„ì„ê¸° - ê°„ì†Œí™”ëœ ë¶„ë¥˜ ì²´ê³„"""
    
    def __init__(self, db_config: Dict[str, str]):
        self.classifier = SimplifiedClassifier()
        self.db_manager = SimplifiedDBManager(db_config)
        self.logger = StructuredLogger()
        
    async def analyze_audio_file(self, audio_file_path: str, audio_file_id: int) -> Dict[str, Any]:
        """ì˜¤ë””ì˜¤ íŒŒì¼ í†µí•© ë¶„ì„"""
        try:
            self.logger.info("ë¶„ì„ ì‹œì‘", {
                "audio_file_path": audio_file_path,
                "audio_file_id": audio_file_id,
                "analysis_type": "integrated"
            })
            
            # 1. í…ìŠ¤íŠ¸ ì¶”ì¶œ ë° ì „ì²˜ë¦¬
            text_content = await self._extract_and_preprocess_text(audio_file_path)
            
            # 2. ìƒë‹´ ë¶„ë¥˜ (í•˜ì´ë¸Œë¦¬ë“œ)
            classification_result = await self._classify_consultation(text_content)
            
            # 3. í’ˆì§ˆ ì§€í‘œ ê³„ì‚°
            quality_metrics = await self._calculate_quality_metrics(text_content)
            
            # 4. ê°ì • ë¶„ì„
            sentiment_analysis = await self._analyze_sentiment(text_content)
            
            # 5. ê²°ê³¼ í†µí•©
            integrated_result = await self._integrate_results(
                audio_file_id, classification_result, 
                quality_metrics, sentiment_analysis
            )
            
            # 6. DB ì €ì¥
            await self._save_results(audio_file_id, integrated_result)
            
            self.logger.info("ë¶„ì„ ì™„ë£Œ", {
                "audio_file_id": audio_file_id,
                "classification_method": classification_result.classification_method,
                "confidence_score": classification_result.confidence_score
            })
            
            return integrated_result
            
        except Exception as e:
            self.logger.error("ë¶„ì„ ì‹¤íŒ¨", {
                "audio_file_id": audio_file_id,
                "error": str(e)
            })
            await self._update_processing_status(audio_file_id, 'failed', str(e))
            raise
    
    async def _extract_and_preprocess_text(self, audio_file_path: str) -> str:
        """í…ìŠ¤íŠ¸ ì¶”ì¶œ ë° ì „ì²˜ë¦¬"""
        try:
            # ìŒì„± ì¸ì‹ (ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” speech recognition ì„œë¹„ìŠ¤ í˜¸ì¶œ)
            # í˜„ì¬ëŠ” ë”ë¯¸ í…ìŠ¤íŠ¸ ë°˜í™˜
            dummy_texts = [
                "ìš”ê¸ˆì œ ë³€ê²½í•˜ê³  ì‹¶ì€ë° ì–´ë–»ê²Œ í•´ì•¼ í•˜ë‚˜ìš”?",
                "íœ´ëŒ€í° ë¶„ì‹¤í–ˆëŠ”ë° ì–´ë–»ê²Œ í•´ì•¼ í•˜ë‚˜ìš”?",
                "ë¶€ê°€ì„œë¹„ìŠ¤ í•´ì§€í•˜ê³  ì‹¶ìŠµë‹ˆë‹¤",
                "ìš”ê¸ˆì´ ë„ˆë¬´ ë¹„ì‹¸ì„œ ë¶ˆë§Œì…ë‹ˆë‹¤",
                "ì†Œì•¡ê²°ì œ í•œë„ ì„¤ì •í•˜ê³  ì‹¶ì–´ìš”"
            ]
            
            import random
            return random.choice(dummy_texts)
            
        except Exception as e:
            logger.error(f"í…ìŠ¤íŠ¸ ì¶”ì¶œ ì‹¤íŒ¨: {e}")
            return None
    
    async def _classify_consultation(self, text_content: str) -> ClassificationResult:
        """ìƒë‹´ ë¶„ë¥˜ (í•˜ì´ë¸Œë¦¬ë“œ)"""
        try:
            # í•˜ì´ë¸Œë¦¬ë“œ ë¶„ë¥˜ ì‹¤í–‰
            result = self.classifier.classify(text_content, method='hybrid')
            
            logger.info(f"ìƒë‹´ ë¶„ë¥˜ ì™„ë£Œ: {result.classification_method}, ì‹ ë¢°ë„: {result.confidence_score:.2f}")
            
            return result
            
        except Exception as e:
            logger.error(f"ìƒë‹´ ë¶„ë¥˜ ì‹¤íŒ¨: {e}")
            # ê¸°ë³¸ê°’ ë°˜í™˜
            return ClassificationResult(
                consultation_subject='ê¸°íƒ€',
                consultation_requirement='ë‹¨ì¼ ìš”ê±´ ë¯¼ì›',
                consultation_content='ì¼ë°˜ ë¬¸ì˜ ìƒë‹´',
                consultation_reason='ë¯¼ì›ì¸',
                consultation_result='ì¶”ê°€ìƒë‹´í•„ìš”',
                business_area='ê¸°íƒ€',
                confidence_score=0.0,
                classification_method='error'
            )
    
    async def _calculate_quality_metrics(self, text_content: str) -> Dict[str, float]:
        """í’ˆì§ˆ ì§€í‘œ ê³„ì‚°"""
        try:
            metrics = {}
            
            # í…ìŠ¤íŠ¸ í’ˆì§ˆ ì§€í‘œ
            if text_content:
                word_count = len(text_content.split())
                metrics['text_length_quality'] = min(word_count / 100.0, 1.0)  # 100ë‹¨ì–´ ê¸°ì¤€
                metrics['text_clarity_quality'] = 0.8  # ê¸°ë³¸ê°’
            
            # í†µí•© í’ˆì§ˆ ì ìˆ˜
            if metrics:
                metrics['overall_quality'] = sum(metrics.values()) / len(metrics)
            else:
                metrics['overall_quality'] = 0.0
            
            return metrics
            
        except Exception as e:
            logger.error(f"í’ˆì§ˆ ì§€í‘œ ê³„ì‚° ì‹¤íŒ¨: {e}")
            return {'overall_quality': 0.0}
    
    async def _analyze_sentiment(self, text_content: str) -> List[Dict[str, Any]]:
        """ê°ì • ë¶„ì„"""
        try:
            # ê°„ë‹¨í•œ ê°ì • ë¶„ì„ (ì‹¤ì œë¡œëŠ” ë” ì •êµí•œ ë¶„ì„ í•„ìš”)
            sentiment_data = []
            
            if text_content:
                # ê¸ì •/ë¶€ì • í‚¤ì›Œë“œ ê¸°ë°˜ ê°ì • ë¶„ì„
                positive_words = ['ì¢‹', 'ë§Œì¡±', 'ê°ì‚¬', 'ê³ ë§™', 'í•´ê²°', 'ì™„ë£Œ']
                negative_words = ['ë¶ˆë§Œ', 'ë¬¸ì œ', 'ì–´ë ¤ì›€', 'í˜ë“¤', 'ì§œì¦', 'í™”ë‚˜']
                
                text_lower = text_content.lower()
                positive_count = sum(1 for word in positive_words if word in text_lower)
                negative_count = sum(1 for word in negative_words if word in text_lower)
                
                if positive_count > negative_count:
                    sentiment_score = 0.7
                    emotion_category = 'satisfied'
                elif negative_count > positive_count:
                    sentiment_score = -0.5
                    emotion_category = 'frustrated'
                else:
                    sentiment_score = 0.0
                    emotion_category = 'neutral'
                
                sentiment_data.append({
                    'speaker_type': 'customer',
                    'time_segment_start': 0.0,
                    'time_segment_end': 300.0,  # 5ë¶„ ê°€ì •
                    'sentiment_score': sentiment_score,
                    'emotion_category': emotion_category,
                    'confidence': 0.8,
                    'emotion_intensity': abs(sentiment_score)
                })
            
            return sentiment_data
            
        except Exception as e:
            logger.error(f"ê°ì • ë¶„ì„ ì‹¤íŒ¨: {e}")
            return []
    
    async def _integrate_results(self, 
                               audio_file_id: int,
                               classification_result: ClassificationResult,
                               quality_metrics: Dict[str, float],
                               sentiment_analysis: List[Dict[str, Any]]) -> Dict[str, Any]:
        """ê²°ê³¼ í†µí•©"""
        try:
            # ìƒë‹´ ìš”ì•½ ìƒì„±
            summary = self._generate_summary(classification_result, quality_metrics)
            
            # í•µì‹¬ ì´ìŠˆ ì¶”ì¶œ
            key_issues = self._extract_key_issues(classification_result, sentiment_analysis)
            
            # í•´ê²° ìƒíƒœ íŒë‹¨
            resolution_status = self._determine_resolution_status(classification_result, quality_metrics)
            
            # ê³ ê° ë§Œì¡±ë„ ì¶”ì •
            customer_satisfaction = self._estimate_customer_satisfaction(sentiment_analysis, quality_metrics)
            
            integrated_result = {
                'audio_file_id': audio_file_id,
                'duration_minutes': 5.0,  # ê¸°ë³¸ê°’
                'business_area': classification_result.business_area,
                'consultation_subject': classification_result.consultation_subject,
                'consultation_requirement': classification_result.consultation_requirement,
                'consultation_content': classification_result.consultation_content,
                'consultation_reason': classification_result.consultation_reason,
                'consultation_result': classification_result.consultation_result,
                'overall_quality_score': quality_metrics.get('overall_quality', 0.0),
                'customer_satisfaction_score': customer_satisfaction,
                'resolution_status': resolution_status,
                'summary': summary,
                'key_issues': key_issues,
                'classification_method': classification_result.classification_method,
                'confidence_score': classification_result.confidence_score,
                'quality_metrics': quality_metrics,
                'sentiment_analysis': sentiment_analysis
            }
            
            return integrated_result
            
        except Exception as e:
            logger.error(f"ê²°ê³¼ í†µí•© ì‹¤íŒ¨: {e}")
            return {}
    
    def _generate_summary(self, classification_result: ClassificationResult, quality_metrics: Dict[str, float]) -> str:
        """ìƒë‹´ ìš”ì•½ ìƒì„±"""
        try:
            subject = classification_result.consultation_subject
            content = classification_result.consultation_content
            result = classification_result.consultation_result
            quality = quality_metrics.get('overall_quality', 0.0)
            
            summary = f"{subject}ì— ëŒ€í•œ {content}ë¡œ {result} ìƒíƒœ"
            
            if quality > 0.7:
                summary += "ì´ë©°, ì „ë°˜ì ìœ¼ë¡œ ì–‘í˜¸í•œ í’ˆì§ˆì˜ ìƒë‹´ì…ë‹ˆë‹¤."
            elif quality > 0.4:
                summary += "ì´ë©°, ë³´í†µ ìˆ˜ì¤€ì˜ ìƒë‹´ì…ë‹ˆë‹¤."
            else:
                summary += "ì´ë©°, ê°œì„ ì´ í•„ìš”í•œ ìƒë‹´ì…ë‹ˆë‹¤."
            
            return summary
            
        except Exception as e:
            logger.error(f"ìš”ì•½ ìƒì„± ì‹¤íŒ¨: {e}")
            return "ìƒë‹´ ë¶„ì„ ì™„ë£Œ"
    
    def _extract_key_issues(self, classification_result: ClassificationResult, sentiment_analysis: List[Dict[str, Any]]) -> Dict[str, Any]:
        """í•µì‹¬ ì´ìŠˆ ì¶”ì¶œ"""
        try:
            key_issues = {
                'main_issue': classification_result.consultation_subject,
                'business_area': classification_result.business_area,
                'resolution': classification_result.consultation_result,
                'sentiment': 'neutral'
            }
            
            # ê°ì • ë¶„ì„ ê²°ê³¼ ë°˜ì˜
            if sentiment_analysis:
                avg_sentiment = sum(s.get('sentiment_score', 0) for s in sentiment_analysis) / len(sentiment_analysis)
                if avg_sentiment > 0.3:
                    key_issues['sentiment'] = 'positive'
                elif avg_sentiment < -0.3:
                    key_issues['sentiment'] = 'negative'
            
            return key_issues
            
        except Exception as e:
            logger.error(f"í•µì‹¬ ì´ìŠˆ ì¶”ì¶œ ì‹¤íŒ¨: {e}")
            return {'main_issue': 'ë¶„ì„ ì˜¤ë¥˜'}
    
    def _determine_resolution_status(self, classification_result: ClassificationResult, quality_metrics: Dict[str, float]) -> str:
        """í•´ê²° ìƒíƒœ íŒë‹¨"""
        try:
            result = classification_result.consultation_result
            quality = quality_metrics.get('overall_quality', 0.0)
            
            if result == 'ë§Œì¡±':
                return 'resolved'
            elif result == 'ë¯¸í¡':
                return 'partially_resolved'
            elif result == 'í•´ê²° ë¶ˆê°€':
                return 'unresolved'
            elif result == 'ì¶”ê°€ìƒë‹´í•„ìš”':
                return 'escalated'
            else:
                return 'unresolved'
                
        except Exception as e:
            logger.error(f"í•´ê²° ìƒíƒœ íŒë‹¨ ì‹¤íŒ¨: {e}")
            return 'unresolved'
    
    def _estimate_customer_satisfaction(self, sentiment_analysis: List[Dict[str, Any]], quality_metrics: Dict[str, float]) -> float:
        """ê³ ê° ë§Œì¡±ë„ ì¶”ì •"""
        try:
            # ê°ì • ë¶„ì„ ê¸°ë°˜ ë§Œì¡±ë„
            if sentiment_analysis:
                avg_sentiment = sum(s.get('sentiment_score', 0) for s in sentiment_analysis) / len(sentiment_analysis)
                sentiment_satisfaction = (avg_sentiment + 1) / 2  # -1~1ì„ 0~1ë¡œ ë³€í™˜
            else:
                sentiment_satisfaction = 0.5
            
            # í’ˆì§ˆ ì§€í‘œ ê¸°ë°˜ ë§Œì¡±ë„
            quality_satisfaction = quality_metrics.get('overall_quality', 0.5)
            
            # ê°€ì¤‘ í‰ê· 
            estimated_satisfaction = (sentiment_satisfaction * 0.6 + quality_satisfaction * 0.4)
            
            return min(max(estimated_satisfaction, 0.0), 1.0)
            
        except Exception as e:
            logger.error(f"ê³ ê° ë§Œì¡±ë„ ì¶”ì • ì‹¤íŒ¨: {e}")
            return 0.5
    
    async def _save_results(self, audio_file_id: int, integrated_result: Dict[str, Any]):
        """ê²°ê³¼ DB ì €ì¥"""
        try:
            # ìƒë‹´ ë¶„ë¥˜ ê²°ê³¼ ì €ì¥
            session_id = self.db_manager.save_consultation_classification(
                audio_file_id, integrated_result
            )
            
            # í’ˆì§ˆ ì§€í‘œ ì €ì¥
            if 'quality_metrics' in integrated_result:
                self.db_manager.save_quality_metrics(session_id, integrated_result['quality_metrics'])
            
            # ê°ì • ë¶„ì„ ì €ì¥
            if 'sentiment_analysis' in integrated_result:
                self.db_manager.save_sentiment_analysis(session_id, integrated_result['sentiment_analysis'])
            
            # ì˜¤ë””ì˜¤ ì²˜ë¦¬ ìƒíƒœ ì—…ë°ì´íŠ¸
            await self._update_processing_status(audio_file_id, 'completed')
            
            logger.info(f"ê²°ê³¼ ì €ì¥ ì™„ë£Œ: session_id={session_id}")
            
        except Exception as e:
            logger.error(f"ê²°ê³¼ ì €ì¥ ì‹¤íŒ¨: {e}")
            await self._update_processing_status(audio_file_id, 'failed', str(e))
            raise
    
    async def _update_processing_status(self, audio_file_id: int, status: str, error_message: str = None):
        """ì²˜ë¦¬ ìƒíƒœ ì—…ë°ì´íŠ¸"""
        try:
            self.db_manager.update_audio_processing_status(audio_file_id, status, error_message)
        except Exception as e:
            logger.error(f"ì²˜ë¦¬ ìƒíƒœ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {e}")
    
    async def get_analysis_report(self) -> Dict[str, Any]:
        """ë¶„ì„ ë¦¬í¬íŠ¸ ìƒì„±"""
        try:
            # ë¶„ë¥˜ ì •í™•ë„ ë¦¬í¬íŠ¸
            accuracy_report = self.db_manager.get_classification_accuracy_report()
            
            # ì—…ë¬´ ë¶„ì•¼ í†µê³„
            business_stats = self.db_manager.get_business_area_statistics()
            
            return {
                'accuracy_report': accuracy_report,
                'business_statistics': business_stats,
                'generated_at': datetime.now().isoformat()
            }
            
        except Exception as e:
            logger.error(f"ë¶„ì„ ë¦¬í¬íŠ¸ ìƒì„± ì‹¤íŒ¨: {e}")
            return {}

# ì‚¬ìš© ì˜ˆì‹œ
async def main():
    # DB ì„¤ì •
    db_config = {
        'host': 'localhost',
        'port': 5432,
        'database': 'callytics',
        'user': 'callytics_user',
        'password': '1234'
    }
    
    analyzer = IntegratedAnalyzer(db_config)
    
    # í…ŒìŠ¤íŠ¸ ë¶„ì„
    audio_file_path = "test_audio.wav"
    audio_file_id = 1
    
    try:
        result = await analyzer.analyze_audio_file(audio_file_path, audio_file_id)
        print(f"ë¶„ì„ ê²°ê³¼: {result}")
        
        # ë¦¬í¬íŠ¸ ìƒì„±
        report = await analyzer.get_analysis_report()
        print(f"ë¶„ì„ ë¦¬í¬íŠ¸: {report}")
        
    except Exception as e:
        print(f"ë¶„ì„ ì‹¤íŒ¨: {e}")
    finally:
        analyzer.db_manager.disconnect()

if __name__ == "__main__":
    asyncio.run(main()) 