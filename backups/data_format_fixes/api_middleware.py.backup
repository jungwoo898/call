#!/usr/bin/env python3
"""
API ìŠ¤í‚¤ë§ˆ ê²€ì¦ ë¯¸ë“¤ì›¨ì–´
ëŸ°íƒ€ì„ì— ìš”ì²­/ì‘ë‹µ ìŠ¤í‚¤ë§ˆ ê²€ì¦ ë° íƒ€ì… ì•ˆì •ì„± ë³´ì¥
"""

import json
import logging
from typing import Dict, Any, Optional, Union
from datetime import datetime
import uuid
from fastapi import Request, Response
from fastapi.responses import JSONResponse
from starlette.middleware.base import BaseHTTPMiddleware
from pydantic import ValidationError

logger = logging.getLogger(__name__)

class SchemaValidationMiddleware(BaseHTTPMiddleware):
    """ìŠ¤í‚¤ë§ˆ ê²€ì¦ ë¯¸ë“¤ì›¨ì–´"""
    
    def __init__(self, app, enable_validation: bool = True, log_violations: bool = True):
        super().__init__(app)
        self.enable_validation = enable_validation
        self.log_violations = log_violations
        self.violation_count = 0
        
    async def dispatch(self, request: Request, call_next):
        # ìš”ì²­ ID ìƒì„±
        request_id = str(uuid.uuid4())[:8]
        request.state.request_id = request_id
        
        # ìš”ì²­ ì „ì²˜ë¦¬
        start_time = datetime.utcnow()
        
        try:
            response = await call_next(request)
            
            # ì‘ë‹µ í›„ì²˜ë¦¬
            if self.enable_validation:
                await self._validate_response(request, response, request_id)
            
            return response
            
        except ValidationError as e:
            logger.error(f"ğŸ”´ ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì‹¤íŒ¨ [{request_id}]: {e}")
            return JSONResponse(
                status_code=400,
                content={
                    "status": "error",
                    "message": "ìš”ì²­ ë°ì´í„° ê²€ì¦ ì‹¤íŒ¨",
                    "error_code": "SCHEMA_VALIDATION_ERROR",
                    "error_details": e.errors(),
                    "request_id": request_id,
                    "timestamp": datetime.utcnow().isoformat() + "Z"
                }
            )
        except Exception as e:
            logger.error(f"ğŸ”´ ë¯¸ë“¤ì›¨ì–´ ì˜¤ë¥˜ [{request_id}]: {e}")
            return JSONResponse(
                status_code=500,
                content={
                    "status": "error", 
                    "message": "ì„œë²„ ë‚´ë¶€ ì˜¤ë¥˜",
                    "request_id": request_id,
                    "timestamp": datetime.utcnow().isoformat() + "Z"
                }
            )
    
    async def _validate_response(self, request: Request, response: Response, request_id: str):
        """ì‘ë‹µ ìŠ¤í‚¤ë§ˆ ê²€ì¦"""
        if hasattr(response, 'body') and response.status_code == 200:
            try:
                # ì‘ë‹µ ë³¸ë¬¸ì´ JSONì¸ì§€ í™•ì¸
                content_type = response.headers.get('content-type', '')
                if 'application/json' in content_type:
                    # ì‘ë‹µ ë°ì´í„° ê²€ì¦
                    await self._check_response_consistency(request, response, request_id)
                    
            except Exception as e:
                if self.log_violations:
                    logger.warning(f"âš ï¸ ì‘ë‹µ ê²€ì¦ ì‹¤íŒ¨ [{request_id}]: {e}")
                self.violation_count += 1
    
    async def _check_response_consistency(self, request: Request, response: Response, request_id: str):
        """ì‘ë‹µ ì¼ê´€ì„± ê²€ì‚¬"""
        try:
            # ì˜ˆìƒ ì‘ë‹µ í•„ë“œ
            required_fields = ["status", "message", "timestamp"]
            
            if hasattr(response, 'body'):
                response_body = response.body
                if isinstance(response_body, bytes):
                    response_data = json.loads(response_body.decode())
                else:
                    response_data = response_body
                
                # í•„ìˆ˜ í•„ë“œ ê²€ì‚¬
                missing_fields = [field for field in required_fields if field not in response_data]
                
                if missing_fields:
                    if self.log_violations:
                        logger.warning(f"âš ï¸ ì‘ë‹µ í•„ë“œ ëˆ„ë½ [{request_id}]: {missing_fields}")
                    self.violation_count += 1
                
                # íƒ€ì… ì¼ê´€ì„± ê²€ì‚¬
                await self._check_type_consistency(response_data, request_id)
                
        except json.JSONDecodeError:
            # JSONì´ ì•„ë‹Œ ì‘ë‹µì€ ê²€ì¦í•˜ì§€ ì•ŠìŒ
            pass
        except Exception as e:
            logger.debug(f"ì‘ë‹µ ê²€ì¦ ì¤‘ ì˜¤ë¥˜ [{request_id}]: {e}")
    
    async def _check_type_consistency(self, response_data: Dict[str, Any], request_id: str):
        """íƒ€ì… ì¼ê´€ì„± ê²€ì‚¬"""
        type_issues = []
        
        # null vs empty ê²€ì‚¬
        for key, value in response_data.items():
            if value == None or value is None:
                type_issues.append(f"'{key}': null/empty ì¼ê´€ì„± í™•ì¸ í•„ìš”")
            elif isinstance(value, list) and len(value) == 0:
                type_issues.append(f"'{key}': ë¹ˆ ë¦¬ìŠ¤íŠ¸ ì²˜ë¦¬ ì¼ê´€ì„± í™•ì¸ í•„ìš”")
        
        if type_issues and self.log_violations:
            logger.warning(f"âš ï¸ íƒ€ì… ì¼ê´€ì„± ë¬¸ì œ [{request_id}]: {'; '.join(type_issues)}")
            self.violation_count += len(type_issues)

class ResponseStandardizer:
    """ì‘ë‹µ í‘œì¤€í™” ìœ í‹¸ë¦¬í‹°"""
    
    @staticmethod
    def util_create_standard_response(
        status: str = "success",
        message: str = None,
        data: Optional[Dict[str, Any]] = None,
        request_id: str | None = None,
        error_code: str | None = None,
        error_details: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """í‘œì¤€í™”ëœ ì‘ë‹µ ìƒì„±"""
        response = {
            "status": status,
            "message": message,
            "timestamp": datetime.utcnow().isoformat() + "Z"
        }
        
        if request_id:
            response["request_id"] = request_id
            
        if data is not None:
            response["data"] = data
            
        if error_code:
            response["error_code"] = error_code
            
        if error_details:
            response["error_details"] = error_details
            
        return response
    
    @staticmethod
    def util_ensure_consistent_types(data: Dict[str, Any]) -> Dict[str, Any]:
        """ì¼ê´€ëœ íƒ€ì…ìœ¼ë¡œ ë³€í™˜"""
        cleaned_data = {}
        
        for key, value in data.items():
            # null/empty ì¼ê´€ì„± ì²˜ë¦¬
            if value is None:
                cleaned_data[key] = None  # nullì€ nullë¡œ ìœ ì§€
            elif value == None:
                cleaned_data[key] = None  # ë¹ˆ ë¬¸ìì—´ì€ nullë¡œ ë³€í™˜
            elif isinstance(value, list) and len(value) == 0:
                cleaned_data[key] = []  # ë¹ˆ ë¦¬ìŠ¤íŠ¸ëŠ” ê·¸ëŒ€ë¡œ ìœ ì§€
            else:
                cleaned_data[key] = value
                
        return cleaned_data

def util_get_schema_validation_stats() -> Dict[str, Any]:
    """ìŠ¤í‚¤ë§ˆ ê²€ì¦ í†µê³„ ë°˜í™˜"""
    # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì „ì—­ ìƒíƒœë‚˜ ë©”íŠ¸ë¦­ ì €ì¥ì†Œì—ì„œ ê°€ì ¸ì˜´
    return {
        "total_violations": 0,
        "common_issues": [
            "response_model ë§¤ê°œë³€ìˆ˜ ëˆ„ë½",
            "JSONResponse ì§ì ‘ ì‚¬ìš©",
            "null vs empty ë¶ˆì¼ì¹˜"
        ],
        "affected_services": [
            "audio-processor",
            "text-processor", 
            "gateway",
            "database-service"
        ]
    }

# FastAPI ì•±ì— ì ìš©í•˜ëŠ” í—¬í¼ í•¨ìˆ˜
def util_setup_schema_validation(app, enable_validation: bool = True):
    """ìŠ¤í‚¤ë§ˆ ê²€ì¦ ë¯¸ë“¤ì›¨ì–´ ì„¤ì •"""
    middleware = SchemaValidationMiddleware(
        app, 
        enable_validation=enable_validation,
        log_violations=True
    )
    app.add_middleware(SchemaValidationMiddleware, 
                      enable_validation=enable_validation,
                      log_violations=True)
    
    logger.info(f"ğŸ” ìŠ¤í‚¤ë§ˆ ê²€ì¦ ë¯¸ë“¤ì›¨ì–´ í™œì„±í™”: {enable_validation}")
    return middleware 