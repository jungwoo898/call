# Standard library imports
import os
import warnings
import hashlib
import json
import time
import threading
from typing import Annotated, Optional, Dict, Any
from pathlib import Path

# Related third-party imports
DEMUCS_AVAILABLE = False
try:
    import demucs.separate
    DEMUCS_AVAILABLE = True
except Exception as e:
    print(f"‚ö†Ô∏è Demucs import failed: {e}")
    DEMUCS_AVAILABLE = False


class AdvancedDemucsVocalSeparator:
    """
    Í≥†ÏÑ±Îä• Î≥¥Ïª¨ Î∂ÑÎ¶¨ ÌÅ¥ÎûòÏä§
    Ï∫êÏã±, Î∂àÌïÑÏöîÌïú Î∂ÑÎ¶¨ ÏÉùÎûµ, ÏùåÏÑ± Í∞êÏßÄ Í∏∞Îä• ÏßÄÏõê
    """
    
    def __init__(self, 
                 model_name: str = "htdemucs",
                 two_stems: str = "vocals",
                 cache_dir: str = "/app/.cache/demucs",
                 enable_cache: bool = True,
                 voice_detection_threshold: float = 0.3):
        """
        AdvancedDemucsVocalSeparator Ï¥àÍ∏∞Ìôî
        
        Parameters
        ----------
        model_name : str
            Demucs Î™®Îç∏Î™Ö
        two_stems : str
            Î∂ÑÎ¶¨Ìï† Ïä§ÌÖú ÌÉÄÏûÖ
        cache_dir : str
            Ï∫êÏãú ÎîîÎ†âÌÜ†Î¶¨
        enable_cache : bool
            Ï∫êÏãú ÌôúÏÑ±Ìôî Ïó¨Î∂Ä
        voice_detection_threshold : float
            ÏùåÏÑ± Í∞êÏßÄ ÏûÑÍ≥ÑÍ∞í
        """
        self.model_name = model_name
        self.two_stems = two_stems
        self.cache_dir = Path(cache_dir)
        self.enable_cache = enable_cache
        self.voice_detection_threshold = voice_detection_threshold
        
        # Ï∫êÏãú ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ±
        if self.enable_cache:
            self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # Ï∫êÏãú Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Í¥ÄÎ¶¨
        self.cache_metadata_file = self.cache_dir / "metadata.json"
        self.cache_metadata = self._load_cache_metadata()
        self.cache_lock = threading.Lock()
        
        # ÏùåÏÑ± Í∞êÏßÄ Î™®Îç∏ (Í∞ÑÎã®Ìïú ÌÜµÍ≥Ñ Í∏∞Î∞ò)
        self.voice_detector = None
        if DEMUCS_AVAILABLE:
            try:
                import librosa
                self.voice_detector = librosa
                print("‚úÖ ÏùåÏÑ± Í∞êÏßÄ Î™®Îç∏ Î°úÎìú ÏôÑÎ£å")
            except Exception as e:
                print(f"‚ö†Ô∏è ÏùåÏÑ± Í∞êÏßÄ Î™®Îç∏ Î°úÎìú Ïã§Ìå®: {e}")
    
    def _load_cache_metadata(self) -> Dict[str, Any]:
        """Ï∫êÏãú Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Î°úÎìú"""
        try:
            if self.cache_metadata_file.exists():
                with open(self.cache_metadata_file, 'r') as f:
                    return json.load(f)
        except Exception as e:
            print(f"‚ö†Ô∏è Ï∫êÏãú Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®: {e}")
        return {}
    
    def _save_cache_metadata(self):
        """Ï∫êÏãú Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Ï†ÄÏû•"""
        try:
            with open(self.cache_metadata_file, 'w') as f:
                json.dump(self.cache_metadata, f, indent=2)
        except Exception as e:
            print(f"‚ö†Ô∏è Ï∫êÏãú Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Ï†ÄÏû• Ïã§Ìå®: {e}")
    
    def _get_cache_key(self, audio_file: str) -> str:
        """Ï∫êÏãú ÌÇ§ ÏÉùÏÑ±"""
        file_hash = hashlib.md5()
        with open(audio_file, 'rb') as f:
            for chunk in iter(lambda: f.read(4096), b""):
                file_hash.update(chunk)
        
        cache_key = f"{file_hash.hexdigest()}_{self.model_name}_{self.two_stems}"
        return cache_key
    
    def _is_cached(self, audio_file: str) -> str | None:
        """Ï∫êÏãúÎêú Í≤∞Í≥º ÌôïÏù∏"""
        if not self.enable_cache:
            return None
        
        cache_key = self._get_cache_key(audio_file)
        
        with self.cache_lock:
            if cache_key in self.cache_metadata:
                cache_info = self.cache_metadata[cache_key]
                cache_path = self.cache_dir / cache_info["filename"]
                
                # Ï∫êÏãú ÌååÏùº Ï°¥Ïû¨ Î∞è Ïú†Ìö®ÏÑ± ÌôïÏù∏
                if cache_path.exists():
                    # ÌååÏùº ÌÅ¨Í∏∞ ÌôïÏù∏
                    if os.path.getsize(cache_path) > 0:
                        return str(cache_path)
                    else:
                        # Îπà ÌååÏùºÏù¥Î©¥ Ï∫êÏãúÏóêÏÑú Ï†úÍ±∞
                        del self.cache_metadata[cache_key]
                        self._save_cache_metadata()
        
        return None
    
    def _save_to_cache(self, audio_file: str, output_path: str):
        """Í≤∞Í≥ºÎ•º Ï∫êÏãúÏóê Ï†ÄÏû•"""
        if not self.enable_cache:
            return
        
        try:
            cache_key = self._get_cache_key(audio_file)
            cache_filename = f"{cache_key}.wav"
            cache_path = self.cache_dir / cache_filename
            
            # Ï∫êÏãúÏóê Î≥µÏÇ¨
            import shutil
            shutil.copy2(output_path, cache_path)
            
            # Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏
            with self.cache_lock:
                self.cache_metadata[cache_key] = {
                    "filename": cache_filename,
                    "original_file": audio_file,
                    "model_name": self.model_name,
                    "two_stems": self.two_stems,
                    "created_at": time.time(),
                    "file_size": os.path.getsize(cache_path)
                }
                self._save_cache_metadata()
            
            print(f"üíæ Ï∫êÏãúÏóê Ï†ÄÏû•: {cache_filename}")
            
        except Exception as e:
            print(f"‚ö†Ô∏è Ï∫êÏãú Ï†ÄÏû• Ïã§Ìå®: {e}")
    
    def _detect_voice_content(self, audio_file: str) -> bool:
        """ÏùåÏÑ± ÎÇ¥Ïö© Í∞êÏßÄ"""
        if self.voice_detector is None:
            return True  # Í∞êÏßÄ Î∂àÍ∞ÄÎä•ÌïòÎ©¥ Î∂ÑÎ¶¨ ÏßÑÌñâ
        
        try:
            # Í∞ÑÎã®Ìïú ÏùåÏÑ± Í∞êÏßÄ (RMS Í∏∞Î∞ò)
            y, sr = self.voice_detector.load(audio_file, sr=None)
            
            # RMS Í≥ÑÏÇ∞
            rms = self.voice_detector.feature.rms(y=y)
            rms_mean = rms.mean()
            
            # ÏùåÏÑ± Ï£ºÌååÏàò ÎåÄÏó≠ ÌïÑÌÑ∞ÎßÅ (300Hz-3400Hz)
            y_filtered = self.voice_detector.effects.preemphasis(y)
            
            # Ïä§ÌéôÌä∏Îüº Ï§ëÏã¨ Í≥ÑÏÇ∞
            spectral_centroids = self.voice_detector.feature.spectral_centroid(y=y_filtered, sr=sr)
            centroid_mean = spectral_centroids.mean()
            
            # ÏùåÏÑ± ÌåêÏ†ï (RMSÏôÄ Ïä§ÌéôÌä∏Îüº Ï§ëÏã¨ Í∏∞Î∞ò)
            is_voice = (rms_mean > self.voice_detection_threshold and 
                       centroid_mean > 1000 and centroid_mean < 3000)
            
            print(f"üé§ ÏùåÏÑ± Í∞êÏßÄ Í≤∞Í≥º: RMS={rms_mean:.3f}, Centroid={centroid_mean:.1f}, ÏùåÏÑ±Ïó¨Î∂Ä={is_voice}")
            
            return is_voice
            
        except Exception as e:
            print(f"‚ö†Ô∏è ÏùåÏÑ± Í∞êÏßÄ Ïã§Ìå®: {e}")
            return True  # Ïã§Ìå®ÌïòÎ©¥ Î∂ÑÎ¶¨ ÏßÑÌñâ
    
    def audio_separate_vocals_advanced(self, audio_file: str, output_dir: str) -> str | None:
        """
        Í≥†ÏÑ±Îä• Î≥¥Ïª¨ Î∂ÑÎ¶¨
        
        Parameters
        ----------
        audio_file : str
            ÏûÖÎ†• Ïò§ÎîîÏò§ ÌååÏùº Í≤ΩÎ°ú
        output_dir : str
            Ï∂úÎ†• ÎîîÎ†âÌÜ†Î¶¨
            
        Returns
        -------
        str | None
            Î∂ÑÎ¶¨Îêú Î≥¥Ïª¨ ÌååÏùº Í≤ΩÎ°ú ÎòêÎäî None
        """
        try:
            # 1. Ï∫êÏãú ÌôïÏù∏
            cached_path = self._is_cached(audio_file)
            if cached_path:
                print(f"üíæ Ï∫êÏãúÏóêÏÑú Î°úÎìú: {cached_path}")
                # Ï∂úÎ†• ÎîîÎ†âÌÜ†Î¶¨Ïóê Î≥µÏÇ¨
                output_filename = f"{Path(audio_file).stem}_{self.two_stems}.wav"
                output_path = os.path.join(output_dir, output_filename)
                import shutil
                shutil.copy2(cached_path, output_path)
                return output_path
            
            # 2. ÏùåÏÑ± ÎÇ¥Ïö© Í∞êÏßÄ
            if not self._detect_voice_content(audio_file):
                print("üéµ ÏùåÏÑ± ÎÇ¥Ïö©Ïù¥ Í∞êÏßÄÎêòÏßÄ ÏïäÏùå. ÏõêÎ≥∏ ÌååÏùº Î∞òÌôò")
                return audio_file
            
            # 3. Demucs Î∂ÑÎ¶¨ Ïã§Ìñâ
            if not DEMUCS_AVAILABLE:
                print("‚ö†Ô∏è Demucs not available. Using original audio file.")
                return audio_file
            
            print(f"üéµ Demucs Î≥¥Ïª¨ Î∂ÑÎ¶¨ ÏãúÏûë: {self.model_name}")
            
            # Ï∂úÎ†• ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ±
            os.makedirs(output_dir, exist_ok=True)
            
            # Demucs Ïã§Ìñâ
            demucs_args = [
                "--two-stems", self.two_stems,
                "-n", self.model_name,
                "-o", output_dir,
                audio_file
            ]
            
            demucs.separate.main(demucs_args)
            
            # Í≤∞Í≥º ÌååÏùº Í≤ΩÎ°ú ÌôïÏù∏
            output_path = os.path.join(
                output_dir, self.model_name,
                os.path.splitext(os.path.basename(audio_file))[0]
            )
            vocal_file = os.path.join(output_path, f"{self.two_stems}.wav")
            
            if os.path.exists(vocal_file) and os.path.getsize(vocal_file) > 0:
                print(f"‚úÖ Î≥¥Ïª¨ Î∂ÑÎ¶¨ ÏôÑÎ£å: {vocal_file}")
                
                # Ï∫êÏãúÏóê Ï†ÄÏû•
                self._save_to_cache(audio_file, vocal_file)
                
                return vocal_file
            else:
                print("‚ö†Ô∏è Î≥¥Ïª¨ Î∂ÑÎ¶¨ Ïã§Ìå®. ÏõêÎ≥∏ ÌååÏùº Î∞òÌôò")
                return audio_file
                
        except Exception as e:
            print(f"‚ö†Ô∏è Î≥¥Ïª¨ Î∂ÑÎ¶¨ Ïò§Î•ò: {e}")
            return audio_file
    
    def audio_cleanup_cache(self, max_age_hours: int = 24):
        """Ïò§ÎûòÎêú Ï∫êÏãú Ï†ïÎ¶¨"""
        try:
            current_time = time.time()
            max_age_seconds = max_age_hours * 3600
            
            with self.cache_lock:
                keys_to_remove = []
                
                for cache_key, cache_info in self.cache_metadata.items():
                    if current_time - cache_info["created_at"] > max_age_seconds:
                        keys_to_remove.append(cache_key)
                
                for cache_key in keys_to_remove:
                    cache_info = self.cache_metadata[cache_key]
                    cache_path = self.cache_dir / cache_info["filename"]
                    
                    try:
                        if cache_path.exists():
                            os.remove(cache_path)
                            print(f"üßπ Ï∫êÏãú Ï†ïÎ¶¨: {cache_info['filename']}")
                    except Exception as e:
                        print(f"‚ö†Ô∏è Ï∫êÏãú ÌååÏùº ÏÇ≠Ï†ú Ïã§Ìå®: {cache_path}, {e}")
                    
                    del self.cache_metadata[cache_key]
                
                if keys_to_remove:
                    self._save_cache_metadata()
                    print(f"üßπ {len(keys_to_remove)}Í∞ú Ï∫êÏãú ÌååÏùº Ï†ïÎ¶¨ ÏôÑÎ£å")
                    
        except Exception as e:
            print(f"‚ö†Ô∏è Ï∫êÏãú Ï†ïÎ¶¨ Ïã§Ìå®: {e}")


class DemucsVocalSeparator:
    """
    A class for separating vocals from an audio file using the Demucs model.

    This class utilizes the Demucs model to separate specified audio stems (e.g., vocals) from an input audio file.
    It supports saving the separated outputs to a specified directory.

    Attributes
    ----------
    model_name : str
        Name of the Demucs model to use for separation.
    two_stems : str
        The stem to isolate (e.g., "vocals").

    Methods
    -------
    audio_separate_vocals(audio_file: str, output_dir: str) -> str | None
        Separates vocals (or other specified stem) from the audio file and returns the path to the separated file.

    """

    def __init__(
            self,
            model_name: Annotated[str, "Demucs model name to use for separation"] = "htdemucs",
            two_stems: Annotated[str, "Stem to isolate (e.g., vocals, drums)"] = "vocals"
    ):
        """
        Initializes the DemucsVocalSeparator with the given parameters.

        Parameters
        ----------
        model_name : str, optional
            Name of the Demucs model to use for separation (default is "htdemucs").
        two_stems : str, optional
            The stem to isolate (default is "vocals").
        """
        self.model_name = model_name
        self.two_stems = two_stems

    def audio_separate_vocals(self, audio_file: str, output_dir: str) -> str | None:
        """
        Separates vocals (or other specified stem) from the audio file.

        This method invokes the Demucs model to isolate a specified audio stem (e.g., vocals).
        The output is saved in WAV format in the specified output directory.

        Parameters
        ----------
        audio_file : str
            Path to the input audio file.
        output_dir : str
            Directory where the separated files will be saved.

        Returns
        -------
        str | None
            Path to the separated vocal file if successful, or the original audio file path if not.

        Raises
        ------
        Warning
            If vocal separation fails or the separated file is not found.

        Examples
        --------
        >>> separator = DemucsVocalSeparator()
        >>> vocal_path = separator.audio_separate_vocals("path/to/audio/file.mp3", "output_dir")
        Vocal separation successful! Outputs saved in WAV format at 'output_dir' directory.
        """
        if not DEMUCS_AVAILABLE:
            print("‚ö†Ô∏è Demucs not available. Using original audio file.")
            warnings.warn("Demucs vocal separation not available; using the original audio file.", stacklevel=2)
            return audio_file
            
        demucs_args = [
            "--two-stems", self.two_stems,
            "-n", self.model_name,
            "-o", output_dir,
            audio_file
        ]

        try:
            demucs.separate.main(demucs_args)
            print(f"Vocal separation successful! Outputs saved in WAV format at '{output_dir}' directory.")

            output_path = os.path.join(
                output_dir, self.model_name,
                os.path.splitext(os.path.basename(audio_file))[0]
            )
            vocal_file = os.path.join(output_path, f"{self.two_stems}.wav")

            if os.path.exists(vocal_file):
                return vocal_file
            else:
                print("Separated vocal file not found. Returning original audio file path.")
                warnings.warn("Vocal separation was unsuccessful; using the original audio file.", stacklevel=2)
                return audio_file

        except Exception as e:
            print(f"An error occurred during vocal separation: {e}")
            warnings.warn("Vocal separation failed; proceeding with the original audio file.", stacklevel=2)
            return audio_file


if __name__ == "__main__":
    file = "example_audio.mp3"
    output_directory = "separated_outputs"
    vocal_separator = DemucsVocalSeparator()
    separated_file_path = vocal_separator.audio_separate_vocals(file, output_directory)
    print(f"Separated file path: {separated_file_path}")
