#!/usr/bin/env python3
"""
Callytics PostgreSQL í†µí•© ë°ì´í„°ë² ì´ìŠ¤ ê´€ë¦¬ì
ì˜¤ë””ì˜¤ ë¶„ì„, ìƒë‹´ í’ˆì§ˆ ë¶„ì„ì„ PostgreSQLë¡œ í†µí•© ê´€ë¦¬
"""

import os
import logging
import asyncio
from typing import Dict, Any, List, Optional, Tuple
from datetime import datetime
import json
import yaml

# PostgreSQL ë§¤ë‹ˆì € import
from .postgres_manager import PostgreSQLManager

logger = logging.getLogger(__name__)

class MultiDatabaseManager:
    """PostgreSQL í†µí•© ë°ì´í„°ë² ì´ìŠ¤ ê´€ë¦¬ì"""
    
    def __init__(self, config_path: str = "config/config.yaml"):
        self.config_path = config_path
        
        # PostgreSQL ë§¤ë‹ˆì € ì´ˆê¸°í™”
        self.postgres_manager: Optional[PostgreSQLManager] = None
        
        # ë¹„ë™ê¸° ì´ˆê¸°í™”ë¥¼ ìœ„í•œ ì´ë²¤íŠ¸ ë£¨í”„ í™•ì¸
        try:
            self.loop = asyncio.get_event_loop()
        except RuntimeError:
            self.loop = asyncio.new_event_loop()
            asyncio.set_event_loop(self.loop)
        
        # PostgreSQL ë§¤ë‹ˆì € ì´ˆê¸°í™”
        self._init_postgresql()
        
        logger.info("PostgreSQL í†µí•© ë°ì´í„°ë² ì´ìŠ¤ ê´€ë¦¬ì ì´ˆê¸°í™” ì™„ë£Œ")
    
    def _init_postgresql(self):
        """PostgreSQL ë§¤ë‹ˆì € ì´ˆê¸°í™” (ì „ìš©)"""
        try:
            # PostgreSQL í™˜ê²½ë³€ìˆ˜ í™•ì¸
            postgres_configured = all([
                os.getenv('POSTGRES_HOST'),
                os.getenv('POSTGRES_DB'),
                os.getenv('POSTGRES_USER'),
                os.getenv('POSTGRES_PASSWORD')
            ])
            
            if postgres_configured:
                logger.info("PostgreSQL ì„¤ì • ë°œê²¬ - PostgreSQL ì—°ê²° ì‹œë„")
                self.postgres_manager = PostgreSQLManager()
                # ë¹„ë™ê¸° ì´ˆê¸°í™” ì‹¤í–‰
                self.loop.run_until_complete(self.postgres_manager.initialize())
                logger.info("âœ… PostgreSQL ì—°ê²° í’€ ì´ˆê¸°í™” ì™„ë£Œ")
            else:
                logger.error("âŒ PostgreSQL ì„¤ì • ë¶€ì¡± - í•„ìˆ˜ í™˜ê²½ë³€ìˆ˜ê°€ ì—†ìŠµë‹ˆë‹¤")
                logger.error("ë‹¤ìŒ í™˜ê²½ë³€ìˆ˜ë¥¼ ì„¤ì •í•˜ì„¸ìš”:")
                logger.error("POSTGRES_HOST, POSTGRES_DB, POSTGRES_USER, POSTGRES_PASSWORD")
                raise ValueError("PostgreSQL ì„¤ì •ì´ ì™„ë£Œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤")
            
        except Exception as e:
            logger.error(f"PostgreSQL ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
            raise
    
    async def _ensure_connection(self):
        """PostgreSQL ì—°ê²° í™•ì¸"""
        if not self.postgres_manager:
            raise RuntimeError("PostgreSQL ë§¤ë‹ˆì €ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤")
            
        if not self.postgres_manager.is_connected:
            try:
                await self.postgres_manager.initialize()
                return True
            except Exception as e:
                logger.error(f"PostgreSQL ì¬ì—°ê²° ì‹¤íŒ¨: {e}")
                raise
        return True
    
    def db_is_postgresql_available(self) -> bool:
        """PostgreSQL ì‚¬ìš© ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸"""
        return self.postgres_manager is not None and self.postgres_manager.is_connected
    
    # ğŸµ ì˜¤ë””ì˜¤ ë¶„ì„ DB ë©”ì„œë“œë“¤ (PostgreSQL í˜¸í™˜)
    
    async def save_audio_file_async(self, file_path: str, file_name: str, file_size: int, 
                                   duration_seconds: float, sample_rate: int, channels: int, 
                                   format_type: str) -> int:
        """ì˜¤ë””ì˜¤ íŒŒì¼ ì •ë³´ ì €ì¥ (ë¹„ë™ê¸°)"""
        await self._ensure_connection()
        
        query = None"
        INSERT INTO audio_files (file_path, file_name, file_size, duration_seconds, 
                               sample_rate, channels, format)
        VALUES ($1, $2, $3, $4, $5, $6, $7)
        RETURNING id
        """
        
        result = await self.postgres_manager.execute_query(
            query, file_path, file_name, file_size, duration_seconds, 
            sample_rate, channels, format_type, fetch_mode="val"
        )
        return result
    
    def db_save_audio_file(self, file_path: str, file_name: str, file_size: int, 
                       duration_seconds: float, sample_rate: int, channels: int, 
                       format_type: str) -> int:
        """ì˜¤ë””ì˜¤ íŒŒì¼ ì •ë³´ ì €ì¥ (ë™ê¸° ë˜í¼)"""
        return self.loop.run_until_complete(
            self.save_audio_file_async(file_path, file_name, file_size, 
                                     duration_seconds, sample_rate, channels, format_type)
        )
    
    async def save_speaker_segments_async(self, audio_file_id: int, segments: List[Dict[str, Any]]):
        """í™”ì ë¶„ë¦¬ ê²°ê³¼ ì €ì¥ (ë¹„ë™ê¸°)"""
        await self._ensure_connection()
        
        if not segments:
            return
        
        # ëŒ€ëŸ‰ ì‚½ì…ì„ ìœ„í•œ ë°ì´í„° ì¤€ë¹„
        data = []
        for segment in segments:
            data.append((
                audio_file_id,
                segment['speaker_id'],
                segment['start_time'],
                segment['end_time'],
                segment.get('confidence'),
                segment.get('speaker_type', 'unknown')
            ))
        
        columns = ['audio_file_id', 'speaker_id', 'start_time', 'end_time', 'confidence', 'speaker_type']
        await self.postgres_manager.bulk_insert('speaker_segments', columns, data)
    
    def db_save_speaker_segments(self, audio_file_id: int, segments: List[Dict[str, Any]]):
        """í™”ì ë¶„ë¦¬ ê²°ê³¼ ì €ì¥ (ë™ê¸° ë˜í¼)"""
        return self.loop.run_until_complete(
            self.save_speaker_segments_async(audio_file_id, segments)
        )
    
    async def save_transcriptions_async(self, audio_file_id: int, transcriptions: List[Dict[str, Any]]):
        """ìŒì„± ì¸ì‹ ê²°ê³¼ ì €ì¥ (ë¹„ë™ê¸°)"""
        await self._ensure_connection()
        
        if not transcriptions:
            return
        
        # ëŒ€ëŸ‰ ì‚½ì…ì„ ìœ„í•œ ë°ì´í„° ì¤€ë¹„
        data = []
        for trans in transcriptions:
            data.append((
                audio_file_id,
                trans.get('speaker_segment_id'),
                trans['text_content'],
                trans['start_time'],
                trans['end_time'],
                trans.get('confidence'),
                trans.get('language', 'ko'),
                trans.get('punctuation_restored', False)
            ))
        
        columns = ['audio_file_id', 'speaker_segment_id', 'text_content', 'start_time', 
                  'end_time', 'confidence', 'language', 'punctuation_restored']
        await self.postgres_manager.bulk_insert('transcriptions', columns, data)
    
    def db_save_transcriptions(self, audio_file_id: int, transcriptions: List[Dict[str, Any]]):
        """ìŒì„± ì¸ì‹ ê²°ê³¼ ì €ì¥ (ë™ê¸° ë˜í¼)"""
        return self.loop.run_until_complete(
            self.save_transcriptions_async(audio_file_id, transcriptions)
        )
    
    async def save_audio_metrics_async(self, audio_file_id: int, metrics: Dict[str, Any]):
        """ì˜¤ë””ì˜¤ í’ˆì§ˆ ì§€í‘œ ì €ì¥ (ë¹„ë™ê¸°)"""
        await self._ensure_connection()
        
        query = None"
        INSERT INTO audio_metrics (audio_file_id, snr_db, clarity_score, volume_level,
                                 background_noise_level, speech_rate, pause_frequency, audio_quality_score)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
        ON CONFLICT (audio_file_id) DO UPDATE SET
            snr_db = EXCLUDED.snr_db,
            clarity_score = EXCLUDED.clarity_score,
            volume_level = EXCLUDED.volume_level,
            background_noise_level = EXCLUDED.background_noise_level,
            speech_rate = EXCLUDED.speech_rate,
            pause_frequency = EXCLUDED.pause_frequency,
            audio_quality_score = EXCLUDED.audio_quality_score
        """
        
        await self.postgres_manager.execute_query(
            query, audio_file_id, metrics.get('snr_db'), metrics.get('clarity_score'),
            metrics.get('volume_level'), metrics.get('background_noise_level'),
            metrics.get('speech_rate'), metrics.get('pause_frequency'), metrics.get('audio_quality_score'),
            fetch_mode="none"
        )
    
    def db_save_audio_metrics(self, audio_file_id: int, metrics: Dict[str, Any]):
        """ì˜¤ë””ì˜¤ í’ˆì§ˆ ì§€í‘œ ì €ì¥ (ë™ê¸° ë˜í¼)"""
        return self.loop.run_until_complete(
            self.save_audio_metrics_async(audio_file_id, metrics)
        )
    
    async def update_audio_processing_status_async(self, audio_file_id: int, status: str, error_message: str = None):
        """ì˜¤ë””ì˜¤ ì²˜ë¦¬ ìƒíƒœ ì—…ë°ì´íŠ¸ (ë¹„ë™ê¸°)"""
        await self._ensure_connection()
        
        if status == 'completed':
            query = None"
                UPDATE audio_files 
            SET processing_status = $1, processing_completed_at = CURRENT_TIMESTAMP, error_message = $2
            WHERE id = $3
            """
        else:
            query = None"
                UPDATE audio_files 
            SET processing_status = $1, error_message = $2
            WHERE id = $3
            """
        
        await self.postgres_manager.execute_query(
            query, status, error_message, audio_file_id, fetch_mode="none"
        )
    
    def db_update_audio_processing_status(self, audio_file_id: int, status: str, error_message: str = None):
        """ì˜¤ë””ì˜¤ ì²˜ë¦¬ ìƒíƒœ ì—…ë°ì´íŠ¸ (ë™ê¸° ë˜í¼)"""
        return self.loop.run_until_complete(
            self.update_audio_processing_status_async(audio_file_id, status, error_message)
        )
    
    # ğŸ§  ìƒë‹´ í’ˆì§ˆ ë¶„ì„ DB ë©”ì„œë“œë“¤ (PostgreSQL í˜¸í™˜)
    
    async def create_consultation_session_async(self, audio_file_id: int, session_date: str, 
                                              duration_minutes: float, agent_name: str = None, 
                                              customer_id: str = None, consultation_type: str = 'other') -> int:
        """ìƒë‹´ ì„¸ì…˜ ìƒì„± (ë¹„ë™ê¸°)"""
        await self._ensure_connection()
        
        query = None"
        INSERT INTO consultation_sessions (audio_file_id, session_date, duration_minutes,
                                         agent_name, customer_id, consultation_type)
        VALUES ($1, $2, $3, $4, $5, $6)
        RETURNING id
        """
        
        result = await self.postgres_manager.execute_query(
            query, audio_file_id, session_date, duration_minutes, agent_name, customer_id, consultation_type,
            fetch_mode="val"
        )
        return result
    
    def db_create_consultation_session(self, audio_file_id: int, session_date: str, 
                                  duration_minutes: float, agent_name: str = None, 
                                  customer_id: str = None, consultation_type: str = 'other') -> int:
        """ìƒë‹´ ì„¸ì…˜ ìƒì„± (ë™ê¸° ë˜í¼)"""
        return self.loop.run_until_complete(
            self.create_consultation_session_async(audio_file_id, session_date, duration_minutes,
                                             agent_name, customer_id, consultation_type)
        )
    
    async def save_quality_metrics_async(self, session_id: int, metrics: List[Dict[str, Any]]):
        """í’ˆì§ˆ í‰ê°€ ì§€í‘œ ì €ì¥ (ë¹„ë™ê¸°)"""
        await self._ensure_connection()
        
        if not metrics:
            return
        
        # ëŒ€ëŸ‰ ì‚½ì…ì„ ìœ„í•œ ë°ì´í„° ì¤€ë¹„
        data = []
        for metric in metrics:
            data.append((
                session_id,
                metric['metric_name'],
                metric['metric_value'],
                metric.get('metric_description'),
                metric.get('weight', 1.0),
                metric.get('category')
            ))
        
        columns = ['session_id', 'metric_name', 'metric_value', 'metric_description', 'weight', 'category']
        await self.postgres_manager.bulk_insert('quality_metrics', columns, data)
    
    def db_save_quality_metrics(self, session_id: int, metrics: List[Dict[str, Any]]):
        """í’ˆì§ˆ í‰ê°€ ì§€í‘œ ì €ì¥ (ë™ê¸° ë˜í¼)"""
        return self.loop.run_until_complete(
            self.save_quality_metrics_async(session_id, metrics)
        )
    
    async def save_sentiment_analysis_async(self, session_id: int, sentiment_data: List[Dict[str, Any]]):
        """ê°ì • ë¶„ì„ ê²°ê³¼ ì €ì¥ (ë¹„ë™ê¸°)"""
        await self._ensure_connection()
        
        if not sentiment_data:
            return
        
        # ëŒ€ëŸ‰ ì‚½ì…ì„ ìœ„í•œ ë°ì´í„° ì¤€ë¹„
        data = []
        for sentiment in sentiment_data:
            data.append((
                session_id,
                sentiment['speaker_type'],
                sentiment.get('time_segment_start'),
                sentiment.get('time_segment_end'),
                sentiment['sentiment_score'],
                sentiment.get('emotion_category'),
                sentiment.get('confidence'),
                sentiment.get('emotion_intensity')
            ))
        
        columns = ['session_id', 'speaker_type', 'time_segment_start', 'time_segment_end',
                  'sentiment_score', 'emotion_category', 'confidence', 'emotion_intensity']
        await self.postgres_manager.bulk_insert('sentiment_analysis', columns, data)
    
    def db_save_sentiment_analysis(self, session_id: int, sentiment_data: List[Dict[str, Any]]):
        """ê°ì • ë¶„ì„ ê²°ê³¼ ì €ì¥ (ë™ê¸° ë˜í¼)"""
        return self.loop.run_until_complete(
            self.save_sentiment_analysis_async(session_id, sentiment_data)
        )
    
    async def save_communication_patterns_async(self, session_id: int, patterns: List[Dict[str, Any]]):
        """ì»¤ë®¤ë‹ˆì¼€ì´ì…˜ íŒ¨í„´ ì €ì¥ (ë¹„ë™ê¸°)"""
        await self._ensure_connection()
        
        if not patterns:
            return
        
        # ëŒ€ëŸ‰ ì‚½ì…ì„ ìœ„í•œ ë°ì´í„° ì¤€ë¹„
        data = []
        for pattern in patterns:
            data.append((
                session_id,
                pattern['pattern_type'],
                pattern.get('frequency', 0),
                pattern.get('severity_score'),
                pattern.get('description'),
                pattern.get('impact_on_quality'),
                json.dumps(pattern.get('time_segments', []))
            ))
        
        columns = ['session_id', 'pattern_type', 'frequency', 'severity_score', 
                  'description', 'impact_on_quality', 'time_segments']
        await self.postgres_manager.bulk_insert('communication_patterns', columns, data)
    
    def db_save_communication_patterns(self, session_id: int, patterns: List[Dict[str, Any]]):
        """ì»¤ë®¤ë‹ˆì¼€ì´ì…˜ íŒ¨í„´ ì €ì¥ (ë™ê¸° ë˜í¼)"""
        return self.loop.run_until_complete(
            self.save_communication_patterns_async(session_id, patterns)
        )
    
    async def save_improvement_suggestions_async(self, session_id: int, suggestions: List[Dict[str, Any]]):
        """ê°œì„  ì œì•ˆì‚¬í•­ ì €ì¥ (ë¹„ë™ê¸°)"""
        await self._ensure_connection()
        
        if not suggestions:
            return
        
        # ëŒ€ëŸ‰ ì‚½ì…ì„ ìœ„í•œ ë°ì´í„° ì¤€ë¹„
        data = []
        for suggestion in suggestions:
            data.append((
                session_id,
                suggestion['suggestion_category'],
                suggestion['suggestion_text'],
                suggestion['priority'],
                suggestion.get('implementation_difficulty'),
                suggestion.get('expected_impact'),
                suggestion.get('target_audience'),
                suggestion.get('estimated_effort_hours')
            ))
        
        columns = ['session_id', 'suggestion_category', 'suggestion_text', 'priority',
                  'implementation_difficulty', 'expected_impact', 'target_audience', 'estimated_effort_hours']
        await self.postgres_manager.bulk_insert('improvement_suggestions', columns, data)
    
    def db_save_improvement_suggestions(self, session_id: int, suggestions: List[Dict[str, Any]]):
        """ê°œì„  ì œì•ˆì‚¬í•­ ì €ì¥ (ë™ê¸° ë˜í¼)"""
        return self.loop.run_until_complete(
            self.save_improvement_suggestions_async(session_id, suggestions)
        )
    
    async def update_consultation_analysis_status_async(self, session_id: int, status: str, 
                                                      overall_quality_score: float = None, 
                                                      customer_satisfaction_score: float = None,
                                                      summary: str = None, key_issues: str = None,
                                                      resolution_status: str = None):
        """ìƒë‹´ ë¶„ì„ ìƒíƒœ ì—…ë°ì´íŠ¸ (ë¹„ë™ê¸°)"""
        await self._ensure_connection()
        
        query = None"
        UPDATE consultation_sessions 
        SET analysis_status = $1, analysis_completed_at = CURRENT_TIMESTAMP,
            overall_quality_score = $2, customer_satisfaction_score = $3,
            summary = $4, key_issues = $5, resolution_status = $6
        WHERE id = $7
        """
        
        # key_issuesë¥¼ JSONBë¡œ ë³€í™˜
        key_issues_json = None
        if key_issues:
            try:
                key_issues_json = json.loads(key_issues) if isinstance(key_issues, str) else key_issues
            except:
                key_issues_json = {"content": str(key_issues)}
        
        await self.postgres_manager.execute_query(
            query, status, overall_quality_score, customer_satisfaction_score,
            summary, key_issues_json, resolution_status, session_id, fetch_mode="none"
        )
    
    def db_update_consultation_analysis_status(self, session_id: int, status: str, 
                                          overall_quality_score: float = None, 
                                          customer_satisfaction_score: float = None,
                                          summary: str = None, key_issues: str = None,
                                          resolution_status: str = None):
        """ìƒë‹´ ë¶„ì„ ìƒíƒœ ì—…ë°ì´íŠ¸ (ë™ê¸° ë˜í¼)"""
        return self.loop.run_until_complete(
            self.update_consultation_analysis_status_async(session_id, status, overall_quality_score,
                                                         customer_satisfaction_score, summary, key_issues, resolution_status)
        )
    
    # ğŸ” ì¡°íšŒ ë©”ì„œë“œë“¤ (PostgreSQL í˜¸í™˜)
    
    async def get_audio_file_by_path_async(self, file_path: str) -> Optional[Dict[str, Any]]:
        """íŒŒì¼ ê²½ë¡œë¡œ ì˜¤ë””ì˜¤ íŒŒì¼ ì¡°íšŒ (ë¹„ë™ê¸°)"""
        await self._ensure_connection()
        
        query = "SELECT * FROM audio_files WHERE file_path = $1"
        result = await self.postgres_manager.execute_query(query, file_path, fetch_mode="one")
        return dict(result) if result else None
    
    def db_get_audio_file_by_path(self, file_path: str) -> Optional[Dict[str, Any]]:
        """íŒŒì¼ ê²½ë¡œë¡œ ì˜¤ë””ì˜¤ íŒŒì¼ ì¡°íšŒ (ë™ê¸° ë˜í¼)"""
        return self.loop.run_until_complete(
            self.get_audio_file_by_path_async(file_path)
        )
    
    async def get_session_by_audio_file_id_async(self, audio_file_id: int) -> Optional[Dict[str, Any]]:
        """ì˜¤ë””ì˜¤ íŒŒì¼ IDë¡œ ìƒë‹´ ì„¸ì…˜ ì¡°íšŒ (ë¹„ë™ê¸°)"""
        await self._ensure_connection()
        
        query = "SELECT * FROM consultation_sessions WHERE audio_file_id = $1"
        result = await self.postgres_manager.execute_query(query, audio_file_id, fetch_mode="one")
        return dict(result) if result else None
    
    def db_get_session_by_audio_file_id(self, audio_file_id: int) -> Optional[Dict[str, Any]]:
        """ì˜¤ë””ì˜¤ íŒŒì¼ IDë¡œ ìƒë‹´ ì„¸ì…˜ ì¡°íšŒ (ë™ê¸° ë˜í¼)"""
        return self.loop.run_until_complete(
            self.get_session_by_audio_file_id_async(audio_file_id)
        )
    
    async def get_complete_analysis_result_async(self, audio_file_id: int) -> Dict[str, Any]:
        """ì™„ì „í•œ ë¶„ì„ ê²°ê³¼ ì¡°íšŒ (ë¹„ë™ê¸°)"""
        await self._ensure_connection()
        
        # ì˜¤ë””ì˜¤ íŒŒì¼ ì •ë³´
        audio_query = "SELECT * FROM audio_files WHERE id = $1"
        audio_result = await self.postgres_manager.execute_query(audio_query, audio_file_id, fetch_mode="one")
        
        if not audio_result:
            return {"error": "ì˜¤ë””ì˜¤ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤"}
        
        result = {
            "audio_file": dict(audio_result),
            "speaker_segments": [],
            "transcriptions": [],
            "audio_metrics": None,
            "consultation_session": None,
            "quality_metrics": [],
            "sentiment_analysis": [],
            "communication_patterns": [],
            "improvement_suggestions": []
        }
        
        # í™”ì ë¶„ë¦¬ ê²°ê³¼
        segments_query = "SELECT * FROM speaker_segments WHERE audio_file_id = $1 ORDER BY start_time"
        segments_result = await self.postgres_manager.execute_query(segments_query, audio_file_id, fetch_mode="all")
        result["speaker_segments"] = [dict(row) for row in segments_result]
        
        # ìŒì„± ì¸ì‹ ê²°ê³¼
        trans_query = "SELECT * FROM transcriptions WHERE audio_file_id = $1 ORDER BY start_time"
        trans_result = await self.postgres_manager.execute_query(trans_query, audio_file_id, fetch_mode="all")
        result["transcriptions"] = [dict(row) for row in trans_result]
        
        # ì˜¤ë””ì˜¤ í’ˆì§ˆ ì§€í‘œ
        metrics_query = "SELECT * FROM audio_metrics WHERE audio_file_id = $1"
        metrics_result = await self.postgres_manager.execute_query(metrics_query, audio_file_id, fetch_mode="one")
        if metrics_result:
            result["audio_metrics"] = dict(metrics_result)
        
        # ìƒë‹´ ì„¸ì…˜ ì •ë³´
        session_query = "SELECT * FROM consultation_sessions WHERE audio_file_id = $1"
        session_result = await self.postgres_manager.execute_query(session_query, audio_file_id, fetch_mode="one")
        if session_result:
            result["consultation_session"] = dict(session_result)
            session_id = session_result['id']
            
            # í’ˆì§ˆ ì§€í‘œ
            quality_query = "SELECT * FROM quality_metrics WHERE session_id = $1"
            quality_result = await self.postgres_manager.execute_query(quality_query, session_id, fetch_mode="all")
            result["quality_metrics"] = [dict(row) for row in quality_result]
            
            # ê°ì • ë¶„ì„
            sentiment_query = "SELECT * FROM sentiment_analysis WHERE session_id = $1 ORDER BY time_segment_start"
            sentiment_result = await self.postgres_manager.execute_query(sentiment_query, session_id, fetch_mode="all")
            result["sentiment_analysis"] = [dict(row) for row in sentiment_result]
            
            # ì»¤ë®¤ë‹ˆì¼€ì´ì…˜ íŒ¨í„´
            pattern_query = "SELECT * FROM communication_patterns WHERE session_id = $1"
            pattern_result = await self.postgres_manager.execute_query(pattern_query, session_id, fetch_mode="all")
            result["communication_patterns"] = [dict(row) for row in pattern_result]
            
            # ê°œì„  ì œì•ˆì‚¬í•­
            suggestion_query = "SELECT * FROM improvement_suggestions WHERE session_id = $1 ORDER BY priority"
            suggestion_result = await self.postgres_manager.execute_query(suggestion_query, session_id, fetch_mode="all")
            result["improvement_suggestions"] = [dict(row) for row in suggestion_result]
        
        return result
    
    def db_get_complete_analysis_result(self, audio_file_id: int) -> Dict[str, Any]:
        """ì™„ì „í•œ ë¶„ì„ ê²°ê³¼ ì¡°íšŒ (ë™ê¸° ë˜í¼)"""
        return self.loop.run_until_complete(
            self.get_complete_analysis_result_async(audio_file_id)
        )
    
    # ğŸ“Š í†µê³„ ë° ê´€ë¦¬ ë©”ì„œë“œë“¤
    
    async def get_database_stats_async(self) -> Dict[str, Any]:
        """ë°ì´í„°ë² ì´ìŠ¤ í†µê³„ ì¡°íšŒ (ë¹„ë™ê¸°)"""
        await self._ensure_connection()
        
        stats = {}
        
        # í…Œì´ë¸”ë³„ ë ˆì½”ë“œ ìˆ˜
        tables = [
            'audio_files', 'speaker_segments', 'transcriptions', 'audio_metrics',
            'consultation_sessions', 'quality_metrics', 'sentiment_analysis',
            'communication_patterns', 'improvement_suggestions'
        ]
        
        for table in tables:
            try:
                count_query = f"SELECT COUNT(*) FROM {table}"
                count = await self.postgres_manager.execute_query(count_query, fetch_mode="val")
                stats[f"{table}_count"] = count
            except Exception as e:
                logger.warning(f"{table} í†µê³„ ì¡°íšŒ ì‹¤íŒ¨: {e}")
                stats[f"{table}_count"] = 0
        
        # PostgreSQL ì—°ê²° í’€ í†µê³„
        if self.postgres_manager:
            pool_stats = self.postgres_manager.get_stats()
            stats["postgres_pool_stats"] = pool_stats
        
        return stats

    def db_get_database_stats(self) -> Dict[str, Any]:
        """ë°ì´í„°ë² ì´ìŠ¤ í†µê³„ ì¡°íšŒ (ë™ê¸° ë˜í¼)"""
        return self.loop.run_until_complete(
            self.get_database_stats_async()
        )
    
    # ğŸ”„ ê¸°ì¡´ í˜¸í™˜ì„± ë©”ì„œë“œë“¤ (PostgreSQLë¡œ ë³€í™˜)
    
    async def db_save_audio_analysis_async(self, result: Dict[str, Any]) -> int | None:
        """ì˜¤ë””ì˜¤ ë¶„ì„ ê²°ê³¼ ì €ì¥ (í†µí•©) - ë¹„ë™ê¸°"""
        try:
            # ì˜¤ë””ì˜¤ íŒŒì¼ ì •ë³´ ì €ì¥
            audio_file_id = await self.save_audio_file_async(
                result['audio_path'],
                result.get('file_name', ''),
                result.get('file_size', 0),
                result.get('duration_seconds', 0),
                result.get('sample_rate', 16000),
                result.get('channels', 1),
                result.get('format', 'mp3')
            )
            
            # í™”ì ë¶„ë¦¬ ê²°ê³¼ ì €ì¥
            if 'speaker_segments' in result:
                await self.save_speaker_segments_async(audio_file_id, result['speaker_segments'])
            
            # ìŒì„± ì¸ì‹ ê²°ê³¼ ì €ì¥
            if 'transcriptions' in result:
                await self.save_transcriptions_async(audio_file_id, result['transcriptions'])
            
            # ì˜¤ë””ì˜¤ í’ˆì§ˆ ì§€í‘œ ì €ì¥
            if 'audio_metrics' in result:
                await self.save_audio_metrics_async(audio_file_id, result['audio_metrics'])
            
            # ì²˜ë¦¬ ìƒíƒœ ì—…ë°ì´íŠ¸
            await self.update_audio_processing_status_async(audio_file_id, 'completed')
            
            return audio_file_id
            
        except Exception as e:
            logger.error(f"ì˜¤ë””ì˜¤ ë¶„ì„ ê²°ê³¼ ì €ì¥ ì‹¤íŒ¨: {e}")
            if 'audio_file_id' in locals():
                await self.update_audio_processing_status_async(audio_file_id, 'failed', str(e))
            raise
    
    def db_save_audio_analysis_async(self, result: Dict[str, Any]) -> int | None:
        """ì˜¤ë””ì˜¤ ë¶„ì„ ê²°ê³¼ ì €ì¥ (í†µí•©) - ë™ê¸° ë˜í¼"""
        return self.loop.run_until_complete(
            self.db_save_audio_analysis_async(result)
        )
    
    async def db_save_quality_analysis_async(self, result: Dict[str, Any]) -> int | None:
        """ìƒë‹´ í’ˆì§ˆ ë¶„ì„ ê²°ê³¼ ì €ì¥ (í†µí•©) - ë¹„ë™ê¸°"""
        try:
            # ìƒë‹´ ì„¸ì…˜ ìƒì„±
            session_id = await self.create_consultation_session_async(
                result.get('audio_file_id'),
                result.get('session_date', get_current_time().strftime("%Y-%m-%d %H:%M:%S")),
                result.get('duration_minutes', 0),
                result.get('agent_name'),
                result.get('customer_id'),
                result.get('consultation_type', 'other')
            )
            
            # í’ˆì§ˆ ì§€í‘œ ì €ì¥
            if 'quality_metrics' in result:
                await self.save_quality_metrics_async(session_id, result['quality_metrics'])
            
            # ê°ì • ë¶„ì„ ì €ì¥
            if 'sentiment_analysis' in result:
                await self.save_sentiment_analysis_async(session_id, result['sentiment_analysis'])
            
            # ì»¤ë®¤ë‹ˆì¼€ì´ì…˜ íŒ¨í„´ ì €ì¥
            if 'communication_patterns' in result:
                await self.save_communication_patterns_async(session_id, result['communication_patterns'])
            
            # ê°œì„  ì œì•ˆì‚¬í•­ ì €ì¥
            if 'improvement_suggestions' in result:
                await self.save_improvement_suggestions_async(session_id, result['improvement_suggestions'])
            
            # ë¶„ì„ ìƒíƒœ ì—…ë°ì´íŠ¸
            await self.update_consultation_analysis_status_async(
                session_id, 'completed',
                result.get('overall_quality_score'),
                result.get('customer_satisfaction_score'),
                result.get('summary'),
                result.get('key_issues'),
                result.get('resolution_status')
            )
            
            return session_id
            
        except Exception as e:
            logger.error(f"ìƒë‹´ í’ˆì§ˆ ë¶„ì„ ê²°ê³¼ ì €ì¥ ì‹¤íŒ¨: {e}")
            raise
    
    def db_save_quality_analysis_async(self, result: Dict[str, Any]) -> int | None:
        """ìƒë‹´ í’ˆì§ˆ ë¶„ì„ ê²°ê³¼ ì €ì¥ (í†µí•©) - ë™ê¸° ë˜í¼"""
        return self.loop.run_until_complete(
            self.db_save_quality_analysis_async(result)
        )
    
    # ğŸ§¹ ì •ë¦¬ ë©”ì„œë“œë“¤
    
    async def close_async(self):
        """PostgreSQL ì—°ê²° ì •ë¦¬ (ë¹„ë™ê¸°)"""
        if self.postgres_manager:
            await self.postgres_manager.db_close()
    
    def db_close(self):
        """PostgreSQL ì—°ê²° ì •ë¦¬ (ë™ê¸° ë˜í¼)"""
        if self.postgres_manager:
            self.loop.run_until_complete(self.postgres_manager.db_close())
    
    def __del__(self):
        """ì†Œë©¸ì"""
        try:
            self.db_close()
        except:
            pass
    
    async def save_communication_quality_async(self, audio_file_id: int, consultation_id: str, 
                                             quality_metrics: Dict[str, Any]):
        """ì»¤ë®¤ë‹ˆì¼€ì´ì…˜ í’ˆì§ˆ ë¶„ì„ ê²°ê³¼ ì €ì¥ (ë¹„ë™ê¸°)"""
        await self._ensure_connection()
        
        query = None"
        INSERT INTO communication_quality (
            audio_file_id, consultation_id,
            honorific_ratio, positive_word_ratio, negative_word_ratio,
            euphonious_word_ratio, empathy_ratio, apology_ratio,
            total_sentences, 
            customer_sentiment_early, customer_sentiment_late, customer_sentiment_trend,
            avg_response_latency, task_ratio,
            suggestions, interruption_count, silence_ratio, talk_ratio,
            analysis_details, created_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, CURRENT_TIMESTAMP)
        ON CONFLICT (audio_file_id, consultation_id) DO UPDATE SET
            honorific_ratio = EXCLUDED.honorific_ratio,
            positive_word_ratio = EXCLUDED.positive_word_ratio,
            negative_word_ratio = EXCLUDED.negative_word_ratio,
            euphonious_word_ratio = EXCLUDED.euphonious_word_ratio,
            empathy_ratio = EXCLUDED.empathy_ratio,
            apology_ratio = EXCLUDED.apology_ratio,
            total_sentences = EXCLUDED.total_sentences,
            customer_sentiment_early = EXCLUDED.customer_sentiment_early,
            customer_sentiment_late = EXCLUDED.customer_sentiment_late,
            customer_sentiment_trend = EXCLUDED.customer_sentiment_trend,
            avg_response_latency = EXCLUDED.avg_response_latency,
            task_ratio = EXCLUDED.task_ratio,
            suggestions = EXCLUDED.suggestions,
            interruption_count = EXCLUDED.interruption_count,
            silence_ratio = EXCLUDED.silence_ratio,
            talk_ratio = EXCLUDED.talk_ratio,
            analysis_details = EXCLUDED.analysis_details,
            updated_at = CURRENT_TIMESTAMP
        """
        
        await self.postgres_manager.execute_query(
            query, 
            audio_file_id, consultation_id,
            quality_metrics.get('honorific_ratio', 0.0),
            quality_metrics.get('positive_word_ratio', 0.0),
            quality_metrics.get('negative_word_ratio', 0.0),
            quality_metrics.get('euphonious_word_ratio', 0.0),
            quality_metrics.get('empathy_ratio', 0.0),
            quality_metrics.get('apology_ratio', 0.0),
            quality_metrics.get('total_sentences', 0),
            quality_metrics.get('customer_sentiment_early', 0.0),
            quality_metrics.get('customer_sentiment_late', 0.0),
            quality_metrics.get('customer_sentiment_trend', 0.0),
            quality_metrics.get('avg_response_latency', 0.0),
            quality_metrics.get('task_ratio', 0.0),
            quality_metrics.get('suggestions', 0.0),
            quality_metrics.get('interruption_count', 0),
            quality_metrics.get('silence_ratio', 0.0),
            quality_metrics.get('talk_ratio', 0.0),
            json.dumps(quality_metrics.get('analysis_details', {})),
            fetch_mode="none"
        )
    
    def db_save_communication_quality(self, audio_file_id: int, consultation_id: str, 
                                 quality_metrics: Dict[str, Any]):
        """ì»¤ë®¤ë‹ˆì¼€ì´ì…˜ í’ˆì§ˆ ë¶„ì„ ê²°ê³¼ ì €ì¥ (ë™ê¸° ë˜í¼)"""
        return self.loop.run_until_complete(
            self.save_communication_quality_async(audio_file_id, consultation_id, quality_metrics)
        ) 