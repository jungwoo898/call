# Standard library imports
import os
import json
import threading
import hashlib
import time
from concurrent.futures import ThreadPoolExecutor, as_completed
from typing import Optional, Tuple, List, Dict, Any
from pathlib import Path

# Related third party imports
import torch
import faster_whisper
from pydub import AudioSegment


class AdvancedTranscriber:
    """
    ê³ ì„±ëŠ¥ STT ì²˜ë¦¬ í´ë˜ìŠ¤
    ìºì‹±, ì‹¤íŒ¨ êµ¬ê°„ ì¬ì‹œë„, ê¸´ ì˜¤ë””ì˜¤ ë¶„í•  ìµœì í™” ì§€ì›
    """

    def __init__(self,
                 model_name: str = 'medium',
                 device: str = 'auto',
                 compute_type: str = 'int8',
                 cache_dir: str = "/app/.cache/stt",
                 max_chunk_duration: int = 300,  # 5ë¶„
                 max_workers: int = 4,
                 enable_cache: bool = True,
                 retry_attempts: int = 3):
        """
        AdvancedTranscriber ì´ˆê¸°í™”

        Parameters
        ----------
        model_name : str
            Whisper ëª¨ë¸ëª…
        device : str
            ì²˜ë¦¬ ë””ë°”ì´ìŠ¤
        compute_type : str
            ê³„ì‚° íƒ€ì…
        cache_dir : str
            ìºì‹œ ë””ë ‰í† ë¦¬
        max_chunk_duration : int
            ìµœëŒ€ chunk ê¸¸ì´ (ì´ˆ)
        max_workers : int
            ë³‘ë ¬ ì²˜ë¦¬ ì›Œì»¤ ìˆ˜
        enable_cache : bool
            ìºì‹œ í™œì„±í™” ì—¬ë¶€
        retry_attempts : int
            ì¬ì‹œë„ íšŸìˆ˜
        """
        self.model_name = model_name
        self.device = self._determine_device(device)
        self.compute_type = compute_type
        self.cache_dir = Path(cache_dir)
        self.max_chunk_duration = max_chunk_duration
        self.max_workers = max_workers
        self.enable_cache = enable_cache
        self.retry_attempts = retry_attempts

        # ìºì‹œ ë””ë ‰í† ë¦¬ ìƒì„±
        if self.enable_cache:
            self.cache_dir.mkdir(parents=True, exist_ok=True)

        # ìºì‹œ ë©”íƒ€ë°ì´í„° ê´€ë¦¬
        self.cache_metadata_file = self.cache_dir / "metadata.json"
        self.cache_metadata = self._load_cache_metadata()
        self.cache_lock = threading.Lock()

        # Whisper ëª¨ë¸ ë¡œë“œ
        self.model = faster_whisper.WhisperModel(
            model_name, device=self.device, compute_type=compute_type
        )

        # ë³‘ë ¬ ì²˜ë¦¬ executor
        self.executor = ThreadPoolExecutor(max_workers=max_workers)

        print(f"âœ… AdvancedTranscriber ì´ˆê¸°í™” ì™„ë£Œ: {model_name}, {self.device}")

    def _determine_device(self, device: str) -> str:
        """ë””ë°”ì´ìŠ¤ ê²°ì •"""
        if device == "auto":
            return "cuda" if torch.cuda.is_available() else "cpu"
        return device

    def _load_cache_metadata(self) -> Dict[str, Any]:
        """ìºì‹œ ë©”íƒ€ë°ì´í„° ë¡œë“œ"""
        try:
            if self.cache_metadata_file.exists():
                with open(self.cache_metadata_file, 'r') as f:
                    return json.load(f)
        except Exception as e:
            print(f"âš ï¸ ìºì‹œ ë©”íƒ€ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨: {e}")
        return {}

    def _save_cache_metadata(self):
        """ìºì‹œ ë©”íƒ€ë°ì´í„° ì €ì¥"""
        try:
            with open(self.cache_metadata_file, 'w') as f:
                json.dump(self.cache_metadata, f, indent=2)
        except Exception as e:
            print(f"âš ï¸ ìºì‹œ ë©”íƒ€ë°ì´í„° ì €ì¥ ì‹¤íŒ¨: {e}")

    def _get_cache_key(self, audio_file: str, start_time: float = 0,
                      end_time: float = 0) -> str:
        """ìºì‹œ í‚¤ ìƒì„±"""
        file_hash = hashlib.md5()
        with open(audio_file, 'rb') as f:
            for chunk in iter(lambda: f.read(4096), b""):
                file_hash.update(chunk)

        # ì‹œê°„ ì •ë³´ í¬í•¨
        time_info = f"{start_time:.1f}_{end_time:.1f}" if end_time > 0 else "full"
        cache_key = f"{file_hash.hexdigest()}_{self.model_name}_{time_info}"
        return cache_key

    def _is_cached(self, audio_file: str, start_time: float = 0,
                  end_time: float = 0) -> Optional[Dict[str, Any]]:
        """ìºì‹œëœ ê²°ê³¼ í™•ì¸"""
        if not self.enable_cache:
            return None

        cache_key = self._get_cache_key(audio_file, start_time, end_time)

        with self.cache_lock:
            if cache_key in self.cache_metadata:
                cache_info = self.cache_metadata[cache_key]
                cache_path = self.cache_dir / cache_info["filename"]

                if cache_path.exists() and os.path.getsize(cache_path) > 0:
                    return cache_info

        return None

    def _save_to_cache(self, audio_file: str, result: Dict[str, Any],
                      start_time: float = 0, end_time: float = 0):
        """ê²°ê³¼ë¥¼ ìºì‹œì— ì €ì¥"""
        if not self.enable_cache:
            return

        try:
            cache_key = self._get_cache_key(audio_file, start_time, end_time)
            cache_filename = f"{cache_key}.json"
            cache_path = self.cache_dir / cache_filename

            # ê²°ê³¼ ì €ì¥
            with open(cache_path, 'w', encoding='utf-8') as f:
                json.dump(result, f, ensure_ascii=False, indent=2)

            # ë©”íƒ€ë°ì´í„° ì—…ë°ì´íŠ¸
            with self.cache_lock:
                self.cache_metadata[cache_key] = {
                    "filename": cache_filename,
                    "original_file": audio_file,
                    "model_name": self.model_name,
                    "start_time": start_time,
                    "end_time": end_time,
                    "created_at": time.time(),
                    "file_size": os.path.getsize(cache_path)
                }
                self._save_cache_metadata()

            print(f"ğŸ’¾ STT ìºì‹œ ì €ì¥: {cache_filename}")

        except Exception as e:
            print(f"âš ï¸ STT ìºì‹œ ì €ì¥ ì‹¤íŒ¨: {e}")

    def _load_from_cache(self, cache_info: Dict[str, Any]) -> Dict[str, Any]:
        """ìºì‹œì—ì„œ ê²°ê³¼ ë¡œë“œ"""
        try:
            cache_path = self.cache_dir / cache_info["filename"]
            with open(cache_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception as e:
            print(f"âš ï¸ ìºì‹œ ë¡œë“œ ì‹¤íŒ¨: {e}")
            return {}

    def _split_audio_optimized(self, audio_file: str) -> List[Tuple[float, float]]:
        """ì˜¤ë””ì˜¤ ìµœì í™” ë¶„í• """
        try:
            # ì˜¤ë””ì˜¤ ê¸¸ì´ í™•ì¸
            audio = AudioSegment.from_file(audio_file)
            duration = len(audio) / 1000.0  # ì´ˆ ë‹¨ìœ„

            if duration <= self.max_chunk_duration:
                return [(0, duration)]

            # ìµœì í™”ëœ ë¶„í•  (ì¹¨ë¬µ êµ¬ê°„ ê³ ë ¤)
            chunks = []
            current_time = 0

            while current_time < duration:
                end_time = min(current_time + self.max_chunk_duration, duration)

                # ì¹¨ë¬µ êµ¬ê°„ ì°¾ê¸° (ë¶„í• ì  ìµœì í™”)
                if end_time < duration:
                    # ë ë¶€ë¶„ì—ì„œ ì¹¨ë¬µ êµ¬ê°„ ì°¾ê¸°
                    chunk_audio = audio[current_time*1000:end_time*1000]
                    silence_threshold = -40  # dB

                    # ì¹¨ë¬µ êµ¬ê°„ ì°¾ê¸°
                    silence_ranges = []
                    for i in range(0, len(chunk_audio), 100):  # 100ms ë‹¨ìœ„
                        segment = chunk_audio[i:i+100]
                        if segment.dBFS < silence_threshold:
                            silence_ranges.append(i/1000.0)

                    # ì¹¨ë¬µ êµ¬ê°„ì´ ìˆìœ¼ë©´ ë¶„í• ì  ì¡°ì •
                    if silence_ranges:
                        # ë§ˆì§€ë§‰ ì¹¨ë¬µ êµ¬ê°„ì„ ë¶„í• ì ìœ¼ë¡œ ì‚¬ìš©
                        optimal_split = current_time + max(silence_ranges)
                        if (optimal_split > current_time + 
                            self.max_chunk_duration * 0.8):  # 80% ì´ìƒì´ë©´
                            end_time = optimal_split

                chunks.append((current_time, end_time))
                current_time = end_time

            print(f"ğŸ“¦ ì˜¤ë””ì˜¤ ë¶„í•  ì™„ë£Œ: {len(chunks)}ê°œ chunk")
            return chunks

        except Exception as e:
            print(f"âš ï¸ ì˜¤ë””ì˜¤ ë¶„í•  ì‹¤íŒ¨: {e}")
            # ê¸°ë³¸ ë¶„í• 
            return [(0, self.max_chunk_duration)]

    def _transcribe_chunk_with_retry(self, audio_file: str, start_time: float,
                                   end_time: float) -> Dict[str, Any]:
        """ì¬ì‹œë„ ë¡œì§ì´ í¬í•¨ëœ chunk STT"""
        for attempt in range(self.retry_attempts):
            try:
                # ìºì‹œ í™•ì¸
                cached_info = self._is_cached(audio_file, start_time, end_time)
                if cached_info:
                    print(f"ğŸ’¾ ìºì‹œì—ì„œ ë¡œë“œ: {start_time:.1f}-{end_time:.1f}")
                    return self._load_from_cache(cached_info)

                # ì„ì‹œ chunk íŒŒì¼ ìƒì„±
                chunk_file = f"/tmp/chunk_{start_time:.1f}_{end_time:.1f}.wav"

                # ffmpegë¡œ chunk ì¶”ì¶œ
                duration = end_time - start_time
                cmd = [
                    "ffmpeg", "-y",
                    "-ss", str(start_time),
                    "-t", str(duration),
                    "-i", audio_file,
                    "-ar", "16000",
                    "-ac", "1",
                    "-f", "wav",
                    chunk_file
                ]

                import subprocess
                result = subprocess.run(cmd, capture_output=True, text=True,
                                      timeout=60)

                if result.returncode != 0:
                    raise Exception(f"Chunk ì¶”ì¶œ ì‹¤íŒ¨: {result.stderr}")

                # STT ì²˜ë¦¬
                segments, info = self.model.transcribe(
                    chunk_file,
                    language="ko",
                    word_timestamps=True,
                    vad_filter=True
                )

                # ê²°ê³¼ ì •ë¦¬
                transcript_result = {
                    "segments": [],
                    "language": info.language,
                    "language_probability": info.language_probability,
                    "start_time": start_time,
                    "end_time": end_time
                }

                for segment in segments:
                    segment_data = {
                        "start": segment.start + start_time,  # ì „ì²´ ì‹œê°„ ê¸°ì¤€ìœ¼ë¡œ ì¡°ì •
                        "end": segment.end + start_time,
                        "text": segment.text.strip(),
                        "words": []
                    }

                    if segment.words:
                        for word in segment.words:
                            word_data = {
                                "start": word.start + start_time,
                                "end": word.end + start_time,
                                "word": word.word,
                                "probability": word.probability
                            }
                            segment_data["words"].append(word_data)

                    transcript_result["segments"].append(segment_data)

                # ìºì‹œì— ì €ì¥
                self._save_to_cache(audio_file, transcript_result, start_time,
                                  end_time)

                # ì„ì‹œ íŒŒì¼ ì •ë¦¬
                if os.path.exists(chunk_file):
                    os.remove(chunk_file)

                print(f"âœ… Chunk STT ì™„ë£Œ: {start_time:.1f}-{end_time:.1f}")
                return transcript_result

            except Exception as e:
                print(f"âš ï¸ Chunk STT ì‹¤íŒ¨ (ì‹œë„ {attempt+1}/{self.retry_attempts}): {e}")
                if attempt == self.retry_attempts - 1:
                    # ë§ˆì§€ë§‰ ì‹œë„ ì‹¤íŒ¨ ì‹œ ë¹ˆ ê²°ê³¼ ë°˜í™˜
                    return {
                        "segments": [],
                        "language": "ko",
                        "language_probability": 0.0,
                        "start_time": start_time,
                        "end_time": end_time,
                        "error": str(e)
                    }

                # ì¬ì‹œë„ ì „ ì ì‹œ ëŒ€ê¸°
                time.sleep(1)

    def audio_transcribe_advanced(self, audio_file: str) -> Dict[str, Any]:
        """
        ê³ ì„±ëŠ¥ STT ì²˜ë¦¬

        Parameters
        ----------
        audio_file : str
            ì…ë ¥ ì˜¤ë””ì˜¤ íŒŒì¼ ê²½ë¡œ

        Returns
        -------
        Dict[str, Any]
            STT ê²°ê³¼
        """
        try:
            print(f"ğŸ¤ ê³ ì„±ëŠ¥ STT ì‹œì‘: {audio_file}")
            start_time = time.time()

            # ì˜¤ë””ì˜¤ ë¶„í• 
            chunks = self._split_audio_optimized(audio_file)

            if len(chunks) == 1:
                # ë‹¨ì¼ chunk ì²˜ë¦¬
                result = self._transcribe_chunk_with_retry(audio_file,
                                                         chunks[0][0],
                                                         chunks[0][1])
            else:
                # ë³‘ë ¬ chunk ì²˜ë¦¬
                print(f"ğŸš€ ë³‘ë ¬ STT ì²˜ë¦¬ ì‹œì‘: {len(chunks)}ê°œ chunk")

                futures = []
                for start, end in chunks:
                    future = self.executor.submit(self._transcribe_chunk_with_retry,
                                                audio_file, start, end)
                    futures.append(future)

                # ê²°ê³¼ ìˆ˜ì§‘ ë° ë³‘í•©
                all_segments = []
                language_info = {"ko": 0}

                for future in as_completed(futures):
                    try:
                        chunk_result = future.result()
                        all_segments.extend(chunk_result["segments"])

                        # ì–¸ì–´ ì •ë³´ í†µê³„
                        lang = chunk_result.get("language", "ko")
                        if lang in language_info:
                            language_info[lang] += 1
                        else:
                            language_info[lang] = 1

                    except Exception as e:
                        print(f"âŒ Chunk ê²°ê³¼ ìˆ˜ì§‘ ì‹¤íŒ¨: {e}")

                # ê²°ê³¼ ì •ë¦¬
                result = {
                    "segments": sorted(all_segments, key=lambda x: x["start"]),
                    "language": max(language_info, key=language_info.get),
                    "language_probability": language_info.get("ko", 0) / len(chunks),
                    "start_time": 0,
                    "end_time": chunks[-1][1] if chunks else 0
                }

            processing_time = time.time() - start_time
            print(f"ğŸ¯ STT ì™„ë£Œ: {len(result['segments'])}ê°œ ì„¸ê·¸ë¨¼íŠ¸, {processing_time:.1f}ì´ˆ")

            return result

        except Exception as e:
            print(f"âš ï¸ ê³ ì„±ëŠ¥ STT ì‹¤íŒ¨: {e}")
            return {
                "segments": [],
                "language": "ko",
                "language_probability": 0.0,
                "start_time": 0,
                "end_time": 0,
                "error": str(e)
            }

    def audio_cleanup_cache(self, max_age_hours: int = 24):
        """ì˜¤ë˜ëœ ìºì‹œ ì •ë¦¬"""
        try:
            current_time = time.time()
            max_age_seconds = max_age_hours * 3600

            with self.cache_lock:
                keys_to_remove = []

                for cache_key, cache_info in self.cache_metadata.items():
                    if (current_time - cache_info["created_at"] > 
                        max_age_seconds):
                        keys_to_remove.append(cache_key)

                for cache_key in keys_to_remove:
                    cache_info = self.cache_metadata[cache_key]
                    cache_path = self.cache_dir / cache_info["filename"]

                    try:
                        if cache_path.exists():
                            os.remove(cache_path)
                            print(f"ğŸ§¹ STT ìºì‹œ ì •ë¦¬: {cache_info['filename']}")
                    except Exception as e:
                        print(f"âš ï¸ STT ìºì‹œ íŒŒì¼ ì‚­ì œ ì‹¤íŒ¨: {cache_path}, {e}")

                    del self.cache_metadata[cache_key]

                if keys_to_remove:
                    self._save_cache_metadata()
                    print(f"ğŸ§¹ {len(keys_to_remove)}ê°œ STT ìºì‹œ íŒŒì¼ ì •ë¦¬ ì™„ë£Œ")

        except Exception as e:
            print(f"âš ï¸ STT ìºì‹œ ì •ë¦¬ ì‹¤íŒ¨: {e}")

    def audio_cleanup(self):
        """ë¦¬ì†ŒìŠ¤ ì •ë¦¬"""
        if self.executor:
            self.executor.shutdown(wait=True) 