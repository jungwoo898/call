#!/usr/bin/env python3
"""
API ìŠ¤í‚¤ë§ˆ ê²€ì¦ ë° OpenAPI ë¬¸ì„œ ìƒì„± ë„êµ¬
íƒ€ì… ë¶ˆì¼ì¹˜, null vs empty ë¬¸ì œ ê°ì§€
"""

import json
import yaml
import logging
from typing import Dict, Any, List, Optional, Union
from pathlib import Path
import requests
from dataclasses import dataclass
from enum import Enum

logger = logging.getLogger(__name__)

class ValidationIssueType(str, Enum):
    """ê²€ì¦ ì´ìŠˆ ìœ í˜•"""
    TYPE_MISMATCH = "type_mismatch"
    NULL_VS_EMPTY = "null_vs_empty"
    MISSING_FIELD = "missing_field"
    EXTRA_FIELD = "extra_field"
    SCHEMA_VIOLATION = "schema_violation"

@dataclass
class ValidationIssue:
    """ê²€ì¦ ì´ìŠˆ"""
    issue_type: ValidationIssueType
    field_path: str
    expected: Any
    actual: Any
    message: str
    severity: str = "warning"  # warning, error, critical

class APISchemaValidator:
    """API ìŠ¤í‚¤ë§ˆ ê²€ì¦ê¸°"""
    
    def __init__(self, service_urls: Dict[str, str]):
        self.service_urls = service_urls
        self.schemas = {}
        self.validation_issues = []
    
    async def collect_openapi_schemas(self) -> Dict[str, Any]:
        """ëª¨ë“  ì„œë¹„ìŠ¤ì˜ OpenAPI ìŠ¤í‚¤ë§ˆ ìˆ˜ì§‘"""
        schemas = {}
        
        for service_name, base_url in self.service_urls.items():
            try:
                # OpenAPI ìŠ¤í‚¤ë§ˆ ë‹¤ìš´ë¡œë“œ
                openapi_url = f"{base_url}/openapi.json"
                response = requests.get(openapi_url, timeout=10)
                
                if response.status_code == 200:
                    schemas[service_name] = response.json()
                    logger.info(f"âœ… {service_name} OpenAPI ìŠ¤í‚¤ë§ˆ ìˆ˜ì§‘ ì™„ë£Œ")
                else:
                    logger.warning(f"âš ï¸ {service_name} OpenAPI ìŠ¤í‚¤ë§ˆ ìˆ˜ì§‘ ì‹¤íŒ¨: {response.status_code}")
                    
            except Exception as e:
                logger.error(f"âŒ {service_name} ìŠ¤í‚¤ë§ˆ ìˆ˜ì§‘ ì˜¤ë¥˜: {e}")
        
        self.schemas = schemas
        return schemas
    
    def util_validate_response_format(self, service_name: str, endpoint: str, 
                                response_data: Dict[str, Any]) -> List[ValidationIssue]:
        """ì‘ë‹µ í˜•ì‹ ê²€ì¦"""
        issues = []
        
        # ê³µí†µ ì‘ë‹µ í˜•ì‹ ê²€ì¦
        required_fields = ["status", "message", "timestamp"]
        for field in required_fields:
            if field not in response_data:
                issues.append(ValidationIssue(
                    issue_type=ValidationIssueType.MISSING_FIELD,
                    field_path=f"{service_name}.{endpoint}.{field}",
                    expected=field,
                    actual="missing",
                    message=f"í•„ìˆ˜ í•„ë“œ '{field}'ê°€ ëˆ„ë½ë¨",
                    severity="error"
                ))
        
        # íƒ€ì… ê²€ì¦
        if "status" in response_data:
            status = response_data["status"]
            valid_statuses = ["success", "error", "processing", "pending"]
            if status not in valid_statuses:
                issues.append(ValidationIssue(
                    issue_type=ValidationIssueType.TYPE_MISMATCH,
                    field_path=f"{service_name}.{endpoint}.status",
                    expected=valid_statuses,
                    actual=status,
                    message=f"ì˜ëª»ëœ status ê°’: {status}",
                    severity="error"
                ))
        
        return issues
    
    def util_check_null_vs_empty_issues(self, data: Any, path: str = "") -> List[ValidationIssue]:
        """null vs empty ë¬¸ì œ ê°ì§€"""
        issues = []
        
        if isinstance(data, dict):
            for key, value in data.items():
                current_path = f"{path}.{key}" if path else key
                
                # null vs empty string ê²€ì‚¬
                if value == "" or value is None:
                    issues.append(ValidationIssue(
                        issue_type=ValidationIssueType.NULL_VS_EMPTY,
                        field_path=current_path,
                        expected="consistent null/empty handling",
                        actual=repr(value),
                        message=f"í•„ë“œ '{current_path}'ì—ì„œ null/empty ì¼ê´€ì„± í™•ì¸ í•„ìš”: {repr(value)}",
                        severity="warning"
                    ))
                
                # ë¹ˆ ë¦¬ìŠ¤íŠ¸ vs null ê²€ì‚¬
                if isinstance(value, list) and len(value) == 0:
                    issues.append(ValidationIssue(
                        issue_type=ValidationIssueType.NULL_VS_EMPTY,
                        field_path=current_path,
                        expected="consistent empty list handling",
                        actual="[]",
                        message=f"ë¹ˆ ë¦¬ìŠ¤íŠ¸ '{current_path}': null vs [] ì¼ê´€ì„± í™•ì¸ í•„ìš”",
                        severity="warning"
                    ))
                
                # ì¬ê·€ì ìœ¼ë¡œ ê²€ì‚¬
                if isinstance(value, (dict, list)):
                    issues.extend(self.util_check_null_vs_empty_issues(value, current_path))
        
        elif isinstance(data, list):
            for i, item in enumerate(data):
                current_path = f"{path}[{i}]"
                if isinstance(item, (dict, list)):
                    issues.extend(self.util_check_null_vs_empty_issues(item, current_path))
        
        return issues
    
    def util_check_type_consistency(self, service_responses: Dict[str, Dict[str, Any]]) -> List[ValidationIssue]:
        """ì„œë¹„ìŠ¤ ê°„ íƒ€ì… ì¼ê´€ì„± ê²€ì‚¬"""
        issues = []
        
        # ëª¨ë“  ì„œë¹„ìŠ¤ì˜ ê³µí†µ í•„ë“œ ìˆ˜ì§‘
        common_fields = {}
        for service_name, endpoints in service_responses.items():
            for endpoint, response in endpoints.items():
                for field, value in response.items():
                    field_key = f"common.{field}"
                    if field_key not in common_fields:
                        common_fields[field_key] = []
                    common_fields[field_key].append({
                        "service": service_name,
                        "endpoint": endpoint,
                        "value": value,
                        "type": type(value).__name__
                    })
        
        # íƒ€ì… ì¼ê´€ì„± ê²€ì‚¬
        for field_key, field_data in common_fields.items():
            if len(field_data) > 1:
                types = set(item["type"] for item in field_data)
                if len(types) > 1:
                    issues.append(ValidationIssue(
                        issue_type=ValidationIssueType.TYPE_MISMATCH,
                        field_path=field_key,
                        expected="consistent type across services",
                        actual=f"ë‹¤ì¤‘ íƒ€ì…: {types}",
                        message=f"ì„œë¹„ìŠ¤ ê°„ '{field_key.split('.')[1]}' í•„ë“œ íƒ€ì… ë¶ˆì¼ì¹˜: {types}",
                        severity="error"
                    ))
        
        return issues
    
    def util_generate_openapi_summary(self) -> Dict[str, Any]:
        """OpenAPI ìŠ¤í‚¤ë§ˆ ìš”ì•½ ìƒì„±"""
        summary = {
            "services": {},
            "common_schemas": {},
            "inconsistencies": []
        }
        
        for service_name, schema in self.schemas.items():
            service_summary = {
                "title": schema.get("info", {}).get("title", "Unknown"),
                "version": schema.get("info", {}).get("version", "Unknown"),
                "endpoints": [],
                "schemas": {}
            }
            
            # ì—”ë“œí¬ì¸íŠ¸ ì •ë³´
            paths = schema.get("paths", {})
            for path, methods in paths.items():
                for method, details in methods.items():
                    if method.upper() in ["GET", "POST", "PUT", "DELETE"]:
                        endpoint_info = {
                            "path": path,
                            "method": method.upper(),
                            "summary": details.get("summary", ""),
                            "request_schema": self._extract_request_schema(details),
                            "response_schema": self._extract_response_schema(details)
                        }
                        service_summary["endpoints"].append(endpoint_info)
            
            # ìŠ¤í‚¤ë§ˆ ì •ë³´
            components = schema.get("components", {})
            schemas = components.get("schemas", {})
            service_summary["schemas"] = list(schemas.keys())
            
            summary["services"][service_name] = service_summary
        
        return summary
    
    def _extract_request_schema(self, endpoint_details: Dict[str, Any]) -> str | None:
        """ìš”ì²­ ìŠ¤í‚¤ë§ˆ ì¶”ì¶œ"""
        request_body = endpoint_details.get("requestBody", {})
        content = request_body.get("content", {})
        json_content = content.get("application/json", {})
        schema_ref = json_content.get("schema", {}).get("$ref", "")
        
        if schema_ref:
            return schema_ref.split("/")[-1]
        return None
    
    def _extract_response_schema(self, endpoint_details: Dict[str, Any]) -> str | None:
        """ì‘ë‹µ ìŠ¤í‚¤ë§ˆ ì¶”ì¶œ"""
        responses = endpoint_details.get("responses", {})
        success_response = responses.get("200", {})
        content = success_response.get("content", {})
        json_content = content.get("application/json", {})
        schema_ref = json_content.get("schema", {}).get("$ref", "")
        
        if schema_ref:
            return schema_ref.split("/")[-1]
        return None
    
    def util_export_validation_report(self, output_path: str = "api_validation_report.json"):
        """ê²€ì¦ ë³´ê³ ì„œ ë‚´ë³´ë‚´ê¸°"""
        report = {
            "timestamp": "2024-07-02T15:30:00Z",
            "summary": {
                "total_issues": len(self.validation_issues),
                "by_severity": {
                    "critical": len([i for i in self.validation_issues if i.severity == "critical"]),
                    "error": len([i for i in self.validation_issues if i.severity == "error"]),
                    "warning": len([i for i in self.validation_issues if i.severity == "warning"])
                },
                "by_type": {}
            },
            "services": list(self.service_urls.keys()),
            "issues": [
                {
                    "type": issue.issue_type,
                    "field_path": issue.field_path,
                    "expected": issue.expected,
                    "actual": issue.actual,
                    "message": issue.message,
                    "severity": issue.severity
                }
                for issue in self.validation_issues
            ],
            "openapi_summary": self.util_generate_openapi_summary()
        }
        
        # íƒ€ì…ë³„ í†µê³„
        for issue in self.validation_issues:
            issue_type = issue.issue_type
            if issue_type not in report["summary"]["by_type"]:
                report["summary"]["by_type"][issue_type] = 0
            report["summary"]["by_type"][issue_type] += 1
        
        with open(output_path, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
        
        logger.info(f"ğŸ“‹ ê²€ì¦ ë³´ê³ ì„œ ìƒì„± ì™„ë£Œ: {output_path}")
        return report

# ì‚¬ìš© ì˜ˆì‹œ
def util_create_validator() -> APISchemaValidator:
    """ê²€ì¦ê¸° ì¸ìŠ¤í„´ìŠ¤ ìƒì„±"""
    service_urls = {
        "api-gateway": "http://localhost:8000",
        "audio-processor": "http://localhost:8001",
        "speaker-diarizer": "http://localhost:8002",
        "speech-recognizer": "http://localhost:8003",
        "punctuation-restorer": "http://localhost:8004",
        "sentiment-analyzer": "http://localhost:8005",
        "llm-analyzer": "http://localhost:8006",
        "database-service": "http://localhost:8007"
    }
    
    return APISchemaValidator(service_urls)

async def run_schema_validation():
    """ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì‹¤í–‰"""
    validator = util_create_validator()
    
    # 1. OpenAPI ìŠ¤í‚¤ë§ˆ ìˆ˜ì§‘
    print("ğŸ“¥ OpenAPI ìŠ¤í‚¤ë§ˆ ìˆ˜ì§‘ ì¤‘...")
    schemas = await validator.collect_openapi_schemas()
    
    # 2. ìƒ˜í”Œ ì‘ë‹µ í…ŒìŠ¤íŠ¸ (ì‹¤ì œë¡œëŠ” ê° ì„œë¹„ìŠ¤ì— ìš”ì²­)
    sample_responses = {
        "audio-processor": {
            "health": {"status": "healthy", "service": "audio-processor", "version": "1.0.0"},
            "preprocess": {"status": "success", "original_path": "/path/to/audio.wav", "processed_path": "/path/to/processed.wav"}
        }
    }
    
    # 3. ê²€ì¦ ì‹¤í–‰
    for service_name, endpoints in sample_responses.items():
        for endpoint, response in endpoints.items():
            issues = validator.util_validate_response_format(service_name, endpoint, response)
            validator.validation_issues.extend(issues)
            
            null_empty_issues = validator.util_check_null_vs_empty_issues(response, f"{service_name}.{endpoint}")
            validator.validation_issues.extend(null_empty_issues)
    
    # 4. íƒ€ì… ì¼ê´€ì„± ê²€ì‚¬
    type_issues = validator.util_check_type_consistency(sample_responses)
    validator.validation_issues.extend(type_issues)
    
    # 5. ë³´ê³ ì„œ ìƒì„±
    report = validator.util_export_validation_report()
    
    print(f"ğŸ” ê²€ì¦ ì™„ë£Œ: {len(validator.validation_issues)}ê°œ ì´ìŠˆ ë°œê²¬")
    for issue in validator.validation_issues:
        print(f"  {issue.severity.upper()}: {issue.message}")
    
    return report

if __name__ == "__main__":
    import asyncio
    asyncio.run(run_schema_validation()) 